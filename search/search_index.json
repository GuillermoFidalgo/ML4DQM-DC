{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Some utilities and example notebooks for ML4DQM/DC This repository contains example code for the ML4DQM/DC project. It was developed with the idea of training autoencoders on the per-lumisection histograms stored in dedicated DQMIO files in order to (partially) automate the DQM and/or DC process. However, it is intended to be generally useful for any ML4DQM/DC study (i.e. any subsystem, any type of histogram, any classification method). In more detail: The framework has been developed based on a number of 1D histograms related to the status of the pixel tracker. Support for 2D histograms was added later. Likewise, most of the development effort went into using an autoencoder as classification algorithm, looking at the mean-squared-difference between a histogram and its reconstruction as a measure for anomality. Support for other algorithms is also present, one just needs to define a class deriving from src/classifiers/HistogramClassifier . Working examples for NMF, PCA and a couple of other classifiers are present in the tutorials. Furthermore, the idea is to train a separate classifier on each histogram type, and then combine the output scores in some way. Using instead only one histogram type is of course also possible (examples are present in the tutorials). Combining histograms in different ways (e.g. appending them together and training an autoencoder on the result) is not explicitly supported yet, though many parts of the code should still be perfectly usable. Structure of this repository There are six important directories: dqmio , tutorials , utils , src , runswan and omsapi . The other directories in the repository contain either data or meta-information (e.g. for documentation). In more detail (in order of most likely appearance): dqmio : contains tools and scripts to read (nano)DQMIO files from DAS and put them in a more useful format. Before starting with further steps, it is recommended to generate small files with only one monitor element per file. See the README in the dqmio folder for more info. Please use the conversion into csv files for now, as this is the expected input for the downstream steps (for historical reasons). This might be made more flexible in the future. Note 1: the nanoDQMIO files are intended to be the new starting point for any ML4DQM-DC study, as of 2022 data-taking. Previously, for 2017 and 2018 data, we had large csv files stored on \\eos that basically contained the full DQMIO content in csv format. They can also still be used as input, for studies on legacy data. But in that case you also need to run a prepocessing step. See the tutorial read_and_write_data.ipynb (more info below). Note 2: The difficulties with using the nanoDQMIO files directly are: that they still contain a relatively large number of monitoring elements (even though reduced with respect to the standard DQMIO format). This makes reading and operating on these files rather slow. Furthermore, many of the tools in the downstream steps assume one monitoring element per file as an input (at least for now, might be made more flexible in the future). that the lumisections belonging to a given data-taking period are split (arbitrarily?) over multiple files. It is often more useful to have all lumisections of a data-taking period in one file. tutorials : contains a number of notebooks that can be used to get familiar with the code and its capabilities (see more info below). utils : contains a number of python files with static utility functions for general use. They are being called and used in various places throughout the code. See the tutorials for examples. src : contains a number of useful classes for this project. See the tutorials for examples of how to use them. DataLoader : class for convenient loading of histograms from the input csv files. HistStruct : a histogram container for easy handling of multiple types of histograms simultaneously and consistently. Model and ModelInterface : a model container that can hold classifiers acting on several histogram types and a combination method to provide a global per-lumisection score. classifiers : folder containing an abstract base HistogramClassifier class and derived classes representing concrete examples of histogram classification algorithms. cloudfitters : folder containing an abstract base CloudFitter class and derived classes representing concrete examples of point cloud fitting algorithms (used when working with multiple types of histograms simultaneously). runswan : contains code for a graphical interface (see more info below). omsapi : standalone API for retrieving information from OMS. Tutorials Some tutorials are located in the tutorials folder in this repository, that should help you get started with the code. They can be grouped into different steps: Put the data in a more manageable format. This step is no longer needed if you start from the (nano)DQMIO files and if you have prepared the data with the scripts in the dqmio folder of this repository. If you start from the legacy csv files however, follow these steps. The raw csv files that are (were) our common input are not very easy to work with. Therefore you would probably first want to do something similar to what's done in the notebook read_and_write_data.ipynb . See the code and inline comments in that script and the functions it refers to for more detailed explanation. Its output is one single csv file per histogram type and per year, which is often much more convenient than the original csv files (which contain all histogram types together and are split per number of lines, not per run). All other functions and notebooks presuppose this first step. Plot the data. Next, you can run plot_histograms.ipynb and plot_histograms_loop.ipynb . These notebooks should help you get a feeling of what your histogram looks like in general, and perhaps help you find some anomalies that you can use for testing. For 2D histograms, look at plot_histograms_2d.ipynb instead. Generate some artificial data for model training and testing, as exemplified in generate_data.ipynb . Train an autoencoder (or any other type of classifier). The scripts autoencoder.ipynb and autoencoder_iterative.ipynb are used to train an autoencoder on the whole dataset or a particular subset respectively. maxpull.ipynb , nmf_1d.ipynb and nmf_2.ipynb are showcases of some other classifiers (a maximum pull with respect to a reference histogram, and an NMF model in 1D and in 2D respectively). Finally, global_combined_training.ipynb shows a more complete example of training a model on several histogram types and combine the output. Graphical interface See more info in the dedicated README in the corresponding folder. Other remarks The repository contains no data files. I was planning to put some example data files in a data folder, but the files are too big for github. You can produce your own input files starting from the (new) nanoDQMIO or the (legacy) csv files as explained above. Another way to get started is to get some example files from my CERNBox Disclaimer: the whole repository is still in development stage. Feel free to contact me (at luka.lambrecht@cern.ch ) in case you found bugs or if you have other suggestions. To get the tutorial notebooks running in SWAN (preferred method): Log in to SWAN. Go to Projects. Click the cloud icon that says 'Download Project from git' Paste the following url: https://github.com/LukaLambrecht/ML4DQM-DC.git . (alternative method): Log in to SWAN. Click on the leftmost icon on the top right ('new terminal'). Navigate to where you want this repository (the starting place is your CERNBox home directory). Paste this command: git clone https://github.com/LukaLambrecht/ML4DQM-DC.git (or however you usually clone a repository). Exit the terminal. The folder should now be where you cloned it, and you can open and run the notebooks in it in SWAN. Further documentation Documentation for all the class definitions and functions in the relevant code directories can be found here . The documentation is generated automatically from annotations in the source code, so the formatting might behave oddly in some cases. Note that the website above does not include documentation for the tutorials (yet?). However, some comments in the tutorial notebooks should provide (enough?) explanation to follow along.","title":"Home"},{"location":"#some-utilities-and-example-notebooks-for-ml4dqmdc","text":"This repository contains example code for the ML4DQM/DC project. It was developed with the idea of training autoencoders on the per-lumisection histograms stored in dedicated DQMIO files in order to (partially) automate the DQM and/or DC process. However, it is intended to be generally useful for any ML4DQM/DC study (i.e. any subsystem, any type of histogram, any classification method). In more detail: The framework has been developed based on a number of 1D histograms related to the status of the pixel tracker. Support for 2D histograms was added later. Likewise, most of the development effort went into using an autoencoder as classification algorithm, looking at the mean-squared-difference between a histogram and its reconstruction as a measure for anomality. Support for other algorithms is also present, one just needs to define a class deriving from src/classifiers/HistogramClassifier . Working examples for NMF, PCA and a couple of other classifiers are present in the tutorials. Furthermore, the idea is to train a separate classifier on each histogram type, and then combine the output scores in some way. Using instead only one histogram type is of course also possible (examples are present in the tutorials). Combining histograms in different ways (e.g. appending them together and training an autoencoder on the result) is not explicitly supported yet, though many parts of the code should still be perfectly usable.","title":"Some utilities and example notebooks for ML4DQM/DC"},{"location":"#structure-of-this-repository","text":"There are six important directories: dqmio , tutorials , utils , src , runswan and omsapi . The other directories in the repository contain either data or meta-information (e.g. for documentation). In more detail (in order of most likely appearance): dqmio : contains tools and scripts to read (nano)DQMIO files from DAS and put them in a more useful format. Before starting with further steps, it is recommended to generate small files with only one monitor element per file. See the README in the dqmio folder for more info. Please use the conversion into csv files for now, as this is the expected input for the downstream steps (for historical reasons). This might be made more flexible in the future. Note 1: the nanoDQMIO files are intended to be the new starting point for any ML4DQM-DC study, as of 2022 data-taking. Previously, for 2017 and 2018 data, we had large csv files stored on \\eos that basically contained the full DQMIO content in csv format. They can also still be used as input, for studies on legacy data. But in that case you also need to run a prepocessing step. See the tutorial read_and_write_data.ipynb (more info below). Note 2: The difficulties with using the nanoDQMIO files directly are: that they still contain a relatively large number of monitoring elements (even though reduced with respect to the standard DQMIO format). This makes reading and operating on these files rather slow. Furthermore, many of the tools in the downstream steps assume one monitoring element per file as an input (at least for now, might be made more flexible in the future). that the lumisections belonging to a given data-taking period are split (arbitrarily?) over multiple files. It is often more useful to have all lumisections of a data-taking period in one file. tutorials : contains a number of notebooks that can be used to get familiar with the code and its capabilities (see more info below). utils : contains a number of python files with static utility functions for general use. They are being called and used in various places throughout the code. See the tutorials for examples. src : contains a number of useful classes for this project. See the tutorials for examples of how to use them. DataLoader : class for convenient loading of histograms from the input csv files. HistStruct : a histogram container for easy handling of multiple types of histograms simultaneously and consistently. Model and ModelInterface : a model container that can hold classifiers acting on several histogram types and a combination method to provide a global per-lumisection score. classifiers : folder containing an abstract base HistogramClassifier class and derived classes representing concrete examples of histogram classification algorithms. cloudfitters : folder containing an abstract base CloudFitter class and derived classes representing concrete examples of point cloud fitting algorithms (used when working with multiple types of histograms simultaneously). runswan : contains code for a graphical interface (see more info below). omsapi : standalone API for retrieving information from OMS.","title":"Structure of this repository"},{"location":"#tutorials","text":"Some tutorials are located in the tutorials folder in this repository, that should help you get started with the code. They can be grouped into different steps: Put the data in a more manageable format. This step is no longer needed if you start from the (nano)DQMIO files and if you have prepared the data with the scripts in the dqmio folder of this repository. If you start from the legacy csv files however, follow these steps. The raw csv files that are (were) our common input are not very easy to work with. Therefore you would probably first want to do something similar to what's done in the notebook read_and_write_data.ipynb . See the code and inline comments in that script and the functions it refers to for more detailed explanation. Its output is one single csv file per histogram type and per year, which is often much more convenient than the original csv files (which contain all histogram types together and are split per number of lines, not per run). All other functions and notebooks presuppose this first step. Plot the data. Next, you can run plot_histograms.ipynb and plot_histograms_loop.ipynb . These notebooks should help you get a feeling of what your histogram looks like in general, and perhaps help you find some anomalies that you can use for testing. For 2D histograms, look at plot_histograms_2d.ipynb instead. Generate some artificial data for model training and testing, as exemplified in generate_data.ipynb . Train an autoencoder (or any other type of classifier). The scripts autoencoder.ipynb and autoencoder_iterative.ipynb are used to train an autoencoder on the whole dataset or a particular subset respectively. maxpull.ipynb , nmf_1d.ipynb and nmf_2.ipynb are showcases of some other classifiers (a maximum pull with respect to a reference histogram, and an NMF model in 1D and in 2D respectively). Finally, global_combined_training.ipynb shows a more complete example of training a model on several histogram types and combine the output.","title":"Tutorials"},{"location":"#graphical-interface","text":"See more info in the dedicated README in the corresponding folder.","title":"Graphical interface"},{"location":"#other-remarks","text":"The repository contains no data files. I was planning to put some example data files in a data folder, but the files are too big for github. You can produce your own input files starting from the (new) nanoDQMIO or the (legacy) csv files as explained above. Another way to get started is to get some example files from my CERNBox Disclaimer: the whole repository is still in development stage. Feel free to contact me (at luka.lambrecht@cern.ch ) in case you found bugs or if you have other suggestions.","title":"Other remarks"},{"location":"#to-get-the-tutorial-notebooks-running-in-swan","text":"","title":"To get the tutorial notebooks running in SWAN"},{"location":"#preferred-method","text":"Log in to SWAN. Go to Projects. Click the cloud icon that says 'Download Project from git' Paste the following url: https://github.com/LukaLambrecht/ML4DQM-DC.git .","title":"(preferred method):"},{"location":"#alternative-method","text":"Log in to SWAN. Click on the leftmost icon on the top right ('new terminal'). Navigate to where you want this repository (the starting place is your CERNBox home directory). Paste this command: git clone https://github.com/LukaLambrecht/ML4DQM-DC.git (or however you usually clone a repository). Exit the terminal. The folder should now be where you cloned it, and you can open and run the notebooks in it in SWAN.","title":"(alternative method):"},{"location":"#further-documentation","text":"Documentation for all the class definitions and functions in the relevant code directories can be found here . The documentation is generated automatically from annotations in the source code, so the formatting might behave oddly in some cases. Note that the website above does not include documentation for the tutorials (yet?). However, some comments in the tutorial notebooks should provide (enough?) explanation to follow along.","title":"Further documentation"},{"location":"dqmio/","text":"Tools for reading (nano)DQMIO files Use cases The tools in this folder can be used to: - read a DQMIO or nanoDQMIO files and extract the monitoring elements. - access CMS DAS and retrieve all files in a given dataset. - convert a collection of nanoDQMIO files to other formats, both interactively and in job submission on lxplus and your local T2 cluster. Where to start The scripts harvest_nanodqmio_to_*.py read one or more (nano)DQMIO files, select a single monitoring element, and write it to a different format. You can run each of these scripts with the option -h to see the available options. The script harvest_nanodqmio_submit.py is a job submission script that wraps any of the scripts above in a Condor job. Run with the option -h to see the available options. The script harvest_nanodqmio_submitmultiple.py has similar functionality to harvest_nanodqmio_submit.py but you can specify multiple monitoring elements at once that will each be written to their own output file. Run with the option -h to see the available options. The folder copydastolocal contains a few scripts to copy remote files or even entire datasets to a local directory, to be used as a backup in case the remote file reading does not work. See the README there for more info. The folder jsons contains an example json file needed as input for harvest_nanodqmio_submitmultiple.py , specifying the monitoring elements to read and their respective output files. You can put your own files with the monitoring elements of your choice in the same directory and specify the file as an input argument to harvest_nanodqmio_submitmultiple.py . The folder src contains the actual (nano)DQMIO reader class and some other tools. You would probably not need to go here unless you found a bug. The folder 'test' contains some testing notebooks that can run e.g. on SWAN. Not needed anymore. Things to keep in mind when trying to read files from DAS: You will need a valid grid certificate. Create one using voms-proxy-init --voms cms . The scripts in this folder should contain the correct export command. If you still get an error concerning X509_USER_PROXY, you can run the command export X509_USER_PROXY=path (where path should be replaced by the path to where you stored the proxy created in the previous step) and try again. Special instructions for job submission: You will need a valid grid certificate if accessing remote files via DAS (see above). Copy the proxy to a location that is accessible from the cluster nodes (e.g. somewhere in you home folder) and make sure to pass the path to it as the proxy argument to the job submission script. You might also need to set a CMSSW environment, depending on the configuration of your cluster. At least on lxplus this appears to be needed. You can do this using the cmssw argument to the job submission script.","title":"README"},{"location":"dqmio/#tools-for-reading-nanodqmio-files","text":"","title":"Tools for reading (nano)DQMIO files"},{"location":"dqmio/#use-cases","text":"The tools in this folder can be used to: - read a DQMIO or nanoDQMIO files and extract the monitoring elements. - access CMS DAS and retrieve all files in a given dataset. - convert a collection of nanoDQMIO files to other formats, both interactively and in job submission on lxplus and your local T2 cluster.","title":"Use cases"},{"location":"dqmio/#where-to-start","text":"The scripts harvest_nanodqmio_to_*.py read one or more (nano)DQMIO files, select a single monitoring element, and write it to a different format. You can run each of these scripts with the option -h to see the available options. The script harvest_nanodqmio_submit.py is a job submission script that wraps any of the scripts above in a Condor job. Run with the option -h to see the available options. The script harvest_nanodqmio_submitmultiple.py has similar functionality to harvest_nanodqmio_submit.py but you can specify multiple monitoring elements at once that will each be written to their own output file. Run with the option -h to see the available options. The folder copydastolocal contains a few scripts to copy remote files or even entire datasets to a local directory, to be used as a backup in case the remote file reading does not work. See the README there for more info. The folder jsons contains an example json file needed as input for harvest_nanodqmio_submitmultiple.py , specifying the monitoring elements to read and their respective output files. You can put your own files with the monitoring elements of your choice in the same directory and specify the file as an input argument to harvest_nanodqmio_submitmultiple.py . The folder src contains the actual (nano)DQMIO reader class and some other tools. You would probably not need to go here unless you found a bug. The folder 'test' contains some testing notebooks that can run e.g. on SWAN. Not needed anymore.","title":"Where to start"},{"location":"dqmio/#things-to-keep-in-mind-when-trying-to-read-files-from-das","text":"You will need a valid grid certificate. Create one using voms-proxy-init --voms cms . The scripts in this folder should contain the correct export command. If you still get an error concerning X509_USER_PROXY, you can run the command export X509_USER_PROXY=path (where path should be replaced by the path to where you stored the proxy created in the previous step) and try again.","title":"Things to keep in mind when trying to read files from DAS:"},{"location":"dqmio/#special-instructions-for-job-submission","text":"You will need a valid grid certificate if accessing remote files via DAS (see above). Copy the proxy to a location that is accessible from the cluster nodes (e.g. somewhere in you home folder) and make sure to pass the path to it as the proxy argument to the job submission script. You might also need to set a CMSSW environment, depending on the configuration of your cluster. At least on lxplus this appears to be needed. You can do this using the cmssw argument to the job submission script.","title":"Special instructions for job submission:"},{"location":"dqmio/harvest_nanodqmio_submit/","text":"harvest nanodqmio submit Submitter for DQMIO conversion scripts This script wraps conversion scripts ( harvest_nanodqmio_to_*.py ) in a job. Run with python harvest_nanodqmio_submit.py -h for a list of available options.","title":"harvest_nanodqmio_submit"},{"location":"dqmio/harvest_nanodqmio_submit/#harvest-nanodqmio-submit","text":"Submitter for DQMIO conversion scripts This script wraps conversion scripts ( harvest_nanodqmio_to_*.py ) in a job. Run with python harvest_nanodqmio_submit.py -h for a list of available options.","title":"harvest nanodqmio submit"},{"location":"dqmio/harvest_nanodqmio_submitmultiple/","text":"harvest nanodqmio submitmultiple Submitter for DQMIO conversion scripts This script wraps conversion scripts ( harvest_nanodqmio_to_*.py ) in a job. The difference with respect to harvest_nanodqmio_submit.py is that this script makes it more easy to harvest multiple monitoring elements in one go (instead of modifying and resubmitting harvest_nanodqmio_submit.py sequentially). Run with python harvest_nanodqmio_submitmultiple.py -h for a list of available options.","title":"harvest_nanodqmio_submitmultiple"},{"location":"dqmio/harvest_nanodqmio_submitmultiple/#harvest-nanodqmio-submitmultiple","text":"Submitter for DQMIO conversion scripts This script wraps conversion scripts ( harvest_nanodqmio_to_*.py ) in a job. The difference with respect to harvest_nanodqmio_submit.py is that this script makes it more easy to harvest multiple monitoring elements in one go (instead of modifying and resubmitting harvest_nanodqmio_submit.py sequentially). Run with python harvest_nanodqmio_submitmultiple.py -h for a list of available options.","title":"harvest nanodqmio submitmultiple"},{"location":"dqmio/harvest_nanodqmio_to_csv/","text":"harvest nanodqmio to csv A script for reading (nano)DQMIO files and storing a ME in a CSV file format Run with python harvest_nanodqmio_to_csv.py -h for a list of available options. The output is stored in a CSV file similar to the ones for the RunII legacy campaign. The file format is targeted to be as close as possible to the RunII legacy files, with the same columns, data types and naming conventions. The only difference is that there are no duplicate columns. While this file format may be far from optimal, it has the advantage that much of the existing code was developed to run on those files, so this is implemented to at least have the option to run on new DQMIO files without any code change. It was tested that the output files from this script can indeed be read correctly by the already existing part of the framework without any code change. Note: need to do definitive check (both for 1D and 2D) with collision data in order to verify that the shapes are correct (hard to tell with cosmics...)","title":"harvest_nanodqmio_to_csv"},{"location":"dqmio/harvest_nanodqmio_to_csv/#harvest-nanodqmio-to-csv","text":"A script for reading (nano)DQMIO files and storing a ME in a CSV file format Run with python harvest_nanodqmio_to_csv.py -h for a list of available options. The output is stored in a CSV file similar to the ones for the RunII legacy campaign. The file format is targeted to be as close as possible to the RunII legacy files, with the same columns, data types and naming conventions. The only difference is that there are no duplicate columns. While this file format may be far from optimal, it has the advantage that much of the existing code was developed to run on those files, so this is implemented to at least have the option to run on new DQMIO files without any code change. It was tested that the output files from this script can indeed be read correctly by the already existing part of the framework without any code change. Note: need to do definitive check (both for 1D and 2D) with collision data in order to verify that the shapes are correct (hard to tell with cosmics...)","title":"harvest nanodqmio to csv"},{"location":"dqmio/harvest_nanodqmio_to_parquet/","text":"harvest nanodqmio to parquet A script for reading (nano)DQMIO files and storing a ME in a parquet file format Run with python harvest_nanodqmio_to_parquet.py -h for a list of available options. Very similar to harvest_nanodqmio_to_csv.py , but store the dataframe as a parquet file instead of a csv file.","title":"harvest_nanodqmio_to_parquet"},{"location":"dqmio/harvest_nanodqmio_to_parquet/#harvest-nanodqmio-to-parquet","text":"A script for reading (nano)DQMIO files and storing a ME in a parquet file format Run with python harvest_nanodqmio_to_parquet.py -h for a list of available options. Very similar to harvest_nanodqmio_to_csv.py , but store the dataframe as a parquet file instead of a csv file.","title":"harvest nanodqmio to parquet"},{"location":"dqmio/harvest_nanodqmio_to_root/","text":"harvest nanodqmio to root A script for reading (nano)DQMIO files and storing a ME in a ROOT file format Run with python harvest_nanodqmio_to_root.py -h for a list of available options. The output is stored in a plain ROOT file, containing only the raw histograms. Run and lumisection information is written to the name of the histogram within the ROOT file.","title":"harvest_nanodqmio_to_root"},{"location":"dqmio/harvest_nanodqmio_to_root/#harvest-nanodqmio-to-root","text":"A script for reading (nano)DQMIO files and storing a ME in a ROOT file format Run with python harvest_nanodqmio_to_root.py -h for a list of available options. The output is stored in a plain ROOT file, containing only the raw histograms. Run and lumisection information is written to the name of the histogram within the ROOT file.","title":"harvest nanodqmio to root"},{"location":"dqmio/copydastolocal/","text":"Tools for copying files or datasets from DAS to local To be used in case remote file access does not work or is too slow, or for debugging. The scripts in this folder can be used to copy a single file or all files in a dataset from DAS to a specified local folder. Then, some ME's can be extracted from them and put in whatever data format is preferred, using the tools in the parent folder with local file access instead of remote file access. When done, the downloaded datasets from DAS can be removed again.","title":"README"},{"location":"dqmio/copydastolocal/copy_das_to_local_file/","text":"copy das to local file Copy a file from DAS to a local area This script copies a file from DAS to a local area. Note: check the file size first, not suitable for extremely large files. Run with python copy_das_to_local_file.py -h to get a list of available command line options.","title":"copy_das_to_local_file"},{"location":"dqmio/copydastolocal/copy_das_to_local_file/#copy-das-to-local-file","text":"Copy a file from DAS to a local area This script copies a file from DAS to a local area. Note: check the file size first, not suitable for extremely large files. Run with python copy_das_to_local_file.py -h to get a list of available command line options.","title":"copy das to local file"},{"location":"dqmio/copydastolocal/copy_das_to_local_set/","text":"copy das to local set Copy an entire dataset from DAS to a local area This script copies a dataset from DAS to a local area. Note: check the size and number of files first, not suitable for large sets. Run with python copy_das_to_local_set.py -h for a list of available command line options.","title":"copy_das_to_local_set"},{"location":"dqmio/copydastolocal/copy_das_to_local_set/#copy-das-to-local-set","text":"Copy an entire dataset from DAS to a local area This script copies a dataset from DAS to a local area. Note: check the size and number of files first, not suitable for large sets. Run with python copy_das_to_local_set.py -h for a list of available command line options.","title":"copy das to local set"},{"location":"dqmio/utils/","text":"Some tools for (nanoDQMIO) file diagnostics","title":"README"},{"location":"dqmio/utils/print_dataset_files/","text":"print dataset files Get the file names belonging to a dataset on DAS Run with python print_dataset_files.py -h for a list of available options.","title":"print_dataset_files"},{"location":"dqmio/utils/print_dataset_files/#print-dataset-files","text":"Get the file names belonging to a dataset on DAS Run with python print_dataset_files.py -h for a list of available options.","title":"print dataset files"},{"location":"dqmio/utils/print_mes/","text":"print mes Print the available monitoring elements in a file Run with python print_mes.py -h for a list of available options.","title":"print_mes"},{"location":"dqmio/utils/print_mes/#print-mes","text":"Print the available monitoring elements in a file Run with python print_mes.py -h for a list of available options.","title":"print mes"},{"location":"omsapi/","text":"OMS API: retrieve information from the OMS database Collection of tools for obtaining OMS information in json-like format. Note: this functionality supersedes the older version in the omsinterface folder! References The code is based on the oms api repository here: https://gitlab.cern.ch/cmsoms/oms-api-client . The file omsapi.py in this folder is a direct copy of the omsapi/__init__.py file in that repository, as recommended by the developers to get it running on SWAN. See also these slides for further info on the setup of the app and this site for the available endpoints. How to use You will need to authenticate through an application registered with the OMS developer team. Either contact me on luka.lambrecht@cern.ch so I can send you my application ID and client secret, or create your own as explained below. Open example.ipynb for some examples. You need to import get_oms_api.py , then create an OMSAPI instance via get_oms_api() (only once, can be re-used for multiple queries) and then query the information via get_oms_data( <arguments> ) . See example.ipynb or get_oms_data.py for details. How to create a personal application for authentication You will need to register a personal application ID and client secret with the OMS developer team. See the slides linked above on how to do that (only slide 4-6 are relevant, the rest has been taken care of). You will receive an application ID and client secret (both are just string-like variables). Create a new python file in this folder called clientid.py and define two variables in there: API_CLIENT_ID = <your application ID> API_CLIENT_SECRET = <your client secret> That should be all!","title":"README"},{"location":"omsapi/#oms-api-retrieve-information-from-the-oms-database","text":"Collection of tools for obtaining OMS information in json-like format. Note: this functionality supersedes the older version in the omsinterface folder!","title":"OMS API: retrieve information from the OMS database"},{"location":"omsapi/#references","text":"The code is based on the oms api repository here: https://gitlab.cern.ch/cmsoms/oms-api-client . The file omsapi.py in this folder is a direct copy of the omsapi/__init__.py file in that repository, as recommended by the developers to get it running on SWAN. See also these slides for further info on the setup of the app and this site for the available endpoints.","title":"References"},{"location":"omsapi/#how-to-use","text":"You will need to authenticate through an application registered with the OMS developer team. Either contact me on luka.lambrecht@cern.ch so I can send you my application ID and client secret, or create your own as explained below. Open example.ipynb for some examples. You need to import get_oms_api.py , then create an OMSAPI instance via get_oms_api() (only once, can be re-used for multiple queries) and then query the information via get_oms_data( <arguments> ) . See example.ipynb or get_oms_data.py for details.","title":"How to use"},{"location":"omsapi/#how-to-create-a-personal-application-for-authentication","text":"You will need to register a personal application ID and client secret with the OMS developer team. See the slides linked above on how to do that (only slide 4-6 are relevant, the rest has been taken care of). You will receive an application ID and client secret (both are just string-like variables). Create a new python file in this folder called clientid.py and define two variables in there: API_CLIENT_ID = <your application ID> API_CLIENT_SECRET = <your client secret> That should be all!","title":"How to create a personal application for authentication"},{"location":"omsapi/get_oms_data/","text":"get oms data Functionality to call the OMS API with the correct query based on input parameters How to use? Check the readme file in this directory for the required setup! In particular, you will need an application ID and client secret to authenticate. Once this is ready, you can do the following: - Import this module, for example via from get_oms_data import get_oms_api, get_oms_data, get_oms_response_attribute - Create an instance of the OMS API class using omsapi = get_oms_api() This instance can be re-used for all consecutive calls to OMS, no need to recreate it for every call. - Make a call to get_oms_data , where the first argument is the instance you just created. Other arguments: see the function documentation below. - The returned object is a complicated dictionary containing all information. Simply print it to find out its exact structure and how to access exactly the values you need. The function get_oms_response_attribute is a small helper function to retrieve a specific attribute from this dictionary. See the notebook example.ipynb in this directory for some examples! get_oms_api full signature: def get_oms_api() comments: get an OMSAPI instance takes no input arguments, as the configuration parameters are unlikely to change very often if needed, these parameters can be changed in the file urls.py get_oms_data full signature: def get_oms_data( omsapi, api_endpoint, runnb=None, fillnb=None, extrafilters=[], extraargs={}, sort=None, attributes=[], limit_entries=1000) comments: query some data from OMS input arguments: - omsapi: an OMSAPI instance, e.g. created by get_oms_api() - api_endpoint: string, target information, e.g. 'runs' or 'lumisections' (see the readme for a link where the available endpoints are listed) - runnb: run number(s) to retrieve the info for, either integer (for single run) or tuple or list of two elements (first run and last run) (can also be None to not filter on run number but this is not recommended) - fillnb: runnb but for fill number instead of run number - extrafilters: list of extra filters (apart from run number), each filter is supposed to be a dict of the form {'attribute_name':<name>,'value':<value>,'operator':<operator>} where <name> must be a valid field name in the OMS data, <value> its value, and <operator> chosen from \"EQ\", \"NEQ\", \"LT\", \"GT\", \"LE\", \"GE\" or \"LIKE\" - extraargs: dict of custom key/value pairs to add to the query (still experimental, potentially usable for changing the granularity from 'run' to 'lumisection' for e.g. L1 trigger rates, see example.ipynb) - sort: valid field name in the OMS data by which to sort - attributes: list of valid field names in the OMS data to return (if not specified, all information is returned) - limit_entries: entry limit for output json object get_oms_response_attribute full signature: def get_oms_response_attribute( omsresponse, attribute ) comments: small helper function to retrieve a list of values for a single attribute input arguments: - omsresponse: the json-like object returned by get_oms_data - attribute: name of one of the attributes present in omsresponse","title":"get_oms_data"},{"location":"omsapi/get_oms_data/#get-oms-data","text":"Functionality to call the OMS API with the correct query based on input parameters How to use? Check the readme file in this directory for the required setup! In particular, you will need an application ID and client secret to authenticate. Once this is ready, you can do the following: - Import this module, for example via from get_oms_data import get_oms_api, get_oms_data, get_oms_response_attribute - Create an instance of the OMS API class using omsapi = get_oms_api() This instance can be re-used for all consecutive calls to OMS, no need to recreate it for every call. - Make a call to get_oms_data , where the first argument is the instance you just created. Other arguments: see the function documentation below. - The returned object is a complicated dictionary containing all information. Simply print it to find out its exact structure and how to access exactly the values you need. The function get_oms_response_attribute is a small helper function to retrieve a specific attribute from this dictionary. See the notebook example.ipynb in this directory for some examples!","title":"get oms data"},{"location":"omsapi/get_oms_data/#get95oms95api","text":"full signature: def get_oms_api() comments: get an OMSAPI instance takes no input arguments, as the configuration parameters are unlikely to change very often if needed, these parameters can be changed in the file urls.py","title":"get_oms_api"},{"location":"omsapi/get_oms_data/#get95oms95data","text":"full signature: def get_oms_data( omsapi, api_endpoint, runnb=None, fillnb=None, extrafilters=[], extraargs={}, sort=None, attributes=[], limit_entries=1000) comments: query some data from OMS input arguments: - omsapi: an OMSAPI instance, e.g. created by get_oms_api() - api_endpoint: string, target information, e.g. 'runs' or 'lumisections' (see the readme for a link where the available endpoints are listed) - runnb: run number(s) to retrieve the info for, either integer (for single run) or tuple or list of two elements (first run and last run) (can also be None to not filter on run number but this is not recommended) - fillnb: runnb but for fill number instead of run number - extrafilters: list of extra filters (apart from run number), each filter is supposed to be a dict of the form {'attribute_name':<name>,'value':<value>,'operator':<operator>} where <name> must be a valid field name in the OMS data, <value> its value, and <operator> chosen from \"EQ\", \"NEQ\", \"LT\", \"GT\", \"LE\", \"GE\" or \"LIKE\" - extraargs: dict of custom key/value pairs to add to the query (still experimental, potentially usable for changing the granularity from 'run' to 'lumisection' for e.g. L1 trigger rates, see example.ipynb) - sort: valid field name in the OMS data by which to sort - attributes: list of valid field names in the OMS data to return (if not specified, all information is returned) - limit_entries: entry limit for output json object","title":"get_oms_data"},{"location":"omsapi/get_oms_data/#get95oms95response95attribute","text":"full signature: def get_oms_response_attribute( omsresponse, attribute ) comments: small helper function to retrieve a list of values for a single attribute input arguments: - omsresponse: the json-like object returned by get_oms_data - attribute: name of one of the attributes present in omsresponse","title":"get_oms_response_attribute"},{"location":"omsapi/omsapi/","text":"omsapi OMS API class Copied from the OMS developers [class] OMSApiException comments: (no valid documentation found) [class] OMSQuery comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, base_url, resource, verbose, cookies, oms_auth, cert_verify, retry_on_err_sec, proxies) comments: (no valid documentation found) \u2937 _attr_exists full signature: def _attr_exists(self, attr) comments: (no valid documentation found) \u2937 _load_meta full signature: def _load_meta(self) comments: (no valid documentation found) \u2937 _warn full signature: def _warn(self, message, raise_exc=False) comments: (no valid documentation found) \u2937 set_verbose full signature: def set_verbose(self, verbose) comments: (no valid documentation found) \u2937 set_validation full signature: def set_validation(self, attribute_validation) comments: (no valid documentation found) \u2937 attrs full signature: def attrs(self, attributes=None) comments: (no valid documentation found) \u2937 filters full signature: def filters(self, filters) comments: (no valid documentation found) \u2937 filter full signature: def filter(self, attribute, value, operator=\"EQ\") comments: (no valid documentation found) \u2937 clear_filter full signature: def clear_filter(self) comments: (no valid documentation found) \u2937 sort full signature: def sort(self, attribute, asc=True) comments: (no valid documentation found) \u2937 paginate full signature: def paginate(self, page=1, per_page=10) comments: (no valid documentation found) \u2937 include full signature: def include(self, key) comments: (no valid documentation found) \u2937 custom full signature: def custom(self, key, value=None) comments: (no valid documentation found) \u2937 data_query full signature: def data_query(self) comments: (no valid documentation found) \u2937 data full signature: def data(self) comments: (no valid documentation found) \u2937 meta full signature: def meta(self) comments: (no valid documentation found) \u2937 get_request full signature: def get_request(self, url, verify=False) comments: (no valid documentation found) [class] OMSAPIOAuth comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, client_id, client_secret, audience=\"cmsoms-prod\", cert_verify=True, proxies={}, retry_on_err_sec=0) comments: (no valid documentation found) \u2937 auth_oidc full signature: def auth_oidc(self) comments: (no valid documentation found) \u2937 auth_oidc_req full signature: def auth_oidc_req(self) comments: (no valid documentation found) [class] OMSAPI comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, api_url=\"https://cmsoms.cern.ch/agg/api\", api_version=\"v1\", verbose=True, cert_verify=True, retry_on_err_sec=0, proxies={}) comments: (no valid documentation found) \u2937 query full signature: def query(self, resource, query_validation=True) comments: (no valid documentation found) \u2937 auth_oidc full signature: def auth_oidc(self, client_id, client_secret, audience=\"cmsoms-prod\", proxies={}) comments: (no valid documentation found) \u2937 auth_krb full signature: def auth_krb(self, cookie_path=\"ssocookies.txt\") comments: (no valid documentation found) rm_file full signature: def rm_file(filename) comments: (no valid documentation found)","title":"omsapi"},{"location":"omsapi/omsapi/#omsapi","text":"OMS API class Copied from the OMS developers","title":"omsapi"},{"location":"omsapi/omsapi/#class-omsapiexception","text":"comments: (no valid documentation found)","title":"[class] OMSApiException"},{"location":"omsapi/omsapi/#class-omsquery","text":"comments: (no valid documentation found)","title":"[class] OMSQuery"},{"location":"omsapi/omsapi/#9595init9595","text":"full signature: def __init__(self, base_url, resource, verbose, cookies, oms_auth, cert_verify, retry_on_err_sec, proxies) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#95attr95exists","text":"full signature: def _attr_exists(self, attr) comments: (no valid documentation found)","title":"&#10551; _attr_exists"},{"location":"omsapi/omsapi/#95load95meta","text":"full signature: def _load_meta(self) comments: (no valid documentation found)","title":"&#10551; _load_meta"},{"location":"omsapi/omsapi/#95warn","text":"full signature: def _warn(self, message, raise_exc=False) comments: (no valid documentation found)","title":"&#10551; _warn"},{"location":"omsapi/omsapi/#set95verbose","text":"full signature: def set_verbose(self, verbose) comments: (no valid documentation found)","title":"&#10551; set_verbose"},{"location":"omsapi/omsapi/#set95validation","text":"full signature: def set_validation(self, attribute_validation) comments: (no valid documentation found)","title":"&#10551; set_validation"},{"location":"omsapi/omsapi/#attrs","text":"full signature: def attrs(self, attributes=None) comments: (no valid documentation found)","title":"&#10551; attrs"},{"location":"omsapi/omsapi/#filters","text":"full signature: def filters(self, filters) comments: (no valid documentation found)","title":"&#10551; filters"},{"location":"omsapi/omsapi/#filter","text":"full signature: def filter(self, attribute, value, operator=\"EQ\") comments: (no valid documentation found)","title":"&#10551; filter"},{"location":"omsapi/omsapi/#clear95filter","text":"full signature: def clear_filter(self) comments: (no valid documentation found)","title":"&#10551; clear_filter"},{"location":"omsapi/omsapi/#sort","text":"full signature: def sort(self, attribute, asc=True) comments: (no valid documentation found)","title":"&#10551; sort"},{"location":"omsapi/omsapi/#paginate","text":"full signature: def paginate(self, page=1, per_page=10) comments: (no valid documentation found)","title":"&#10551; paginate"},{"location":"omsapi/omsapi/#include","text":"full signature: def include(self, key) comments: (no valid documentation found)","title":"&#10551; include"},{"location":"omsapi/omsapi/#custom","text":"full signature: def custom(self, key, value=None) comments: (no valid documentation found)","title":"&#10551; custom"},{"location":"omsapi/omsapi/#data95query","text":"full signature: def data_query(self) comments: (no valid documentation found)","title":"&#10551; data_query"},{"location":"omsapi/omsapi/#data","text":"full signature: def data(self) comments: (no valid documentation found)","title":"&#10551; data"},{"location":"omsapi/omsapi/#meta","text":"full signature: def meta(self) comments: (no valid documentation found)","title":"&#10551; meta"},{"location":"omsapi/omsapi/#get95request","text":"full signature: def get_request(self, url, verify=False) comments: (no valid documentation found)","title":"&#10551; get_request"},{"location":"omsapi/omsapi/#class-omsapioauth","text":"comments: (no valid documentation found)","title":"[class] OMSAPIOAuth"},{"location":"omsapi/omsapi/#9595init9595_1","text":"full signature: def __init__(self, client_id, client_secret, audience=\"cmsoms-prod\", cert_verify=True, proxies={}, retry_on_err_sec=0) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#auth95oidc","text":"full signature: def auth_oidc(self) comments: (no valid documentation found)","title":"&#10551; auth_oidc"},{"location":"omsapi/omsapi/#auth95oidc95req","text":"full signature: def auth_oidc_req(self) comments: (no valid documentation found)","title":"&#10551; auth_oidc_req"},{"location":"omsapi/omsapi/#class-omsapi","text":"comments: (no valid documentation found)","title":"[class] OMSAPI"},{"location":"omsapi/omsapi/#9595init9595_2","text":"full signature: def __init__(self, api_url=\"https://cmsoms.cern.ch/agg/api\", api_version=\"v1\", verbose=True, cert_verify=True, retry_on_err_sec=0, proxies={}) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"omsapi/omsapi/#query","text":"full signature: def query(self, resource, query_validation=True) comments: (no valid documentation found)","title":"&#10551; query"},{"location":"omsapi/omsapi/#auth95oidc_1","text":"full signature: def auth_oidc(self, client_id, client_secret, audience=\"cmsoms-prod\", proxies={}) comments: (no valid documentation found)","title":"&#10551; auth_oidc"},{"location":"omsapi/omsapi/#auth95krb","text":"full signature: def auth_krb(self, cookie_path=\"ssocookies.txt\") comments: (no valid documentation found)","title":"&#10551; auth_krb"},{"location":"omsapi/omsapi/#rm95file","text":"full signature: def rm_file(filename) comments: (no valid documentation found)","title":"rm_file"},{"location":"omsapi/urls/","text":"urls Definition of URLs to be used for the API queries","title":"urls"},{"location":"omsapi/urls/#urls","text":"Definition of URLs to be used for the API queries","title":"urls"},{"location":"run/","text":"Run the ML4DQM functionality using the GUI !WARNING: superseded by a newer version of the GUI running in SWAN! See the folder 'runswan' as opposed to here. The GUI here is not maintained (for now) and will not work anymore due to changes in the source code. All information below is kept for reference but is outdated. How to start the program The GUI cannot be run in SWAN, it needs to be run locally on your computer. You can either download the full repository, or a single executable file. Option 1: downloading the repository Go to the GitHub page and clone or download the repository via git. In the main project directory, avigate to the run folder and start the program via python3 gui.py . Dependencies: - You need to have python installed. The GUI will not work with python 2, it is required to use python 3. - Apart from tools within this repository, there are quite a few other python dependencies, such as matplotlib, numpy, math, pandas, etc. To do: make complete list of dependencies. Option 2: download executable file Go to this CERNBox location and download the executable file with the most recent date (format: gui_vYYYYMMDD ). Run via ./gui_<version> . Drawbacks: - The file is rather large (about 600MB) since it includes a complete python interpreter. - So far only a Linux version is available; it will not work on Windows or MacOS. Where to start? The starting screen of the GUI shows a number of buttons and text boxes. Usually one would start by loading a previously stored HistStruct (a structure containing all relevant histograms and classifiers) via the 'Load' button, or create a new one via the 'New' button. Many of the other buttons will not work if you have not loaded or created a valid HistStruct first. To create a HistStruct, the GUI expects input files in a specific format, see below. Input files Some example input files are provided on this CERNBox location . They are skimmed versions of the centrally provided csv files with monintoring elements (both 1D and 2D histograms) with a per-lumisection granularity. The central files are available on EOS: /eos/project/c/cmsml4dc/ML_2020 . How to produce your own skimmed input files from the centrally provided csv files is still under discussion. The code to do so is available in this repository (if run on SWAN, which has direct access to EOS), but not in the executable file (which is run locally). To do: update documentation when other options are available. The HistStruct object The 'HistStruct' is the central object used in this program. It contains all relevant histograms (depending on the target run, training runs and histogram types) and their respective classifiers in a structured way. Selecting subsets of histograms, e.g. for classifier training or evaluation, is managed by using masks, which you can initialize when creating the HistStruct. There are three types of masks: - run masks: select lumisections belonging to a given run number. - statistics masks: select lumisections with high or low statistics. Currently the criterion is simply based on the number of histogram entries divided by the number of bins. Might be extended in the future. - json masks: select lumisections with a custom json file in the same format as the typical so-called golden json file. Any json file in the correct format can be uploaded, which allows full flexibility in selecting lumisections. Typical workflow After having loaded or created a new HistStruct object, you can start the training and evaluation of histogram classifiers. A typical workflow would consist of (most of) the following steps: - preprocessing the histograms (i.e. rebinning, normalizing and/or cropping). See the 'Preprocessing' button. - make plots of the training set, target set and other histograms that might be relevant. See the 'Plotting' button. - resample the training set to increase statistics (might not be needed for some types of classifiers). See the 'Resampling' button. - adding classifiers for each histogram type. See the 'Add classifiers' button. - train all classifiers. See the 'Train classifiers' button. - fit a probability density function to the resulting classifier scores in order to get from a per-histogram score to a per-lumisection score. See the 'Fit' button. - evaluate the model. See 'Evaluate model' button. - take a closer look at some lumisections. For example in the case of an autoencoder one might be interested to compare the original histogram to its autoencoder reconstruction. Or more generally one could be interested to see what histogram types are causing the high lumisection score. See 'Plot lumisection' button. Example usage Some examples on how to use the GUI are put in slides and collected on this CERNBox location","title":"README"},{"location":"run/#run-the-ml4dqm-functionality-using-the-gui","text":"!WARNING: superseded by a newer version of the GUI running in SWAN! See the folder 'runswan' as opposed to here. The GUI here is not maintained (for now) and will not work anymore due to changes in the source code. All information below is kept for reference but is outdated.","title":"Run the ML4DQM functionality using the GUI"},{"location":"run/#how-to-start-the-program","text":"The GUI cannot be run in SWAN, it needs to be run locally on your computer. You can either download the full repository, or a single executable file.","title":"How to start the program"},{"location":"run/#option-1-downloading-the-repository","text":"Go to the GitHub page and clone or download the repository via git. In the main project directory, avigate to the run folder and start the program via python3 gui.py . Dependencies: - You need to have python installed. The GUI will not work with python 2, it is required to use python 3. - Apart from tools within this repository, there are quite a few other python dependencies, such as matplotlib, numpy, math, pandas, etc. To do: make complete list of dependencies.","title":"Option 1: downloading the repository"},{"location":"run/#option-2-download-executable-file","text":"Go to this CERNBox location and download the executable file with the most recent date (format: gui_vYYYYMMDD ). Run via ./gui_<version> . Drawbacks: - The file is rather large (about 600MB) since it includes a complete python interpreter. - So far only a Linux version is available; it will not work on Windows or MacOS.","title":"Option 2: download executable file"},{"location":"run/#where-to-start","text":"The starting screen of the GUI shows a number of buttons and text boxes. Usually one would start by loading a previously stored HistStruct (a structure containing all relevant histograms and classifiers) via the 'Load' button, or create a new one via the 'New' button. Many of the other buttons will not work if you have not loaded or created a valid HistStruct first. To create a HistStruct, the GUI expects input files in a specific format, see below.","title":"Where to start?"},{"location":"run/#input-files","text":"Some example input files are provided on this CERNBox location . They are skimmed versions of the centrally provided csv files with monintoring elements (both 1D and 2D histograms) with a per-lumisection granularity. The central files are available on EOS: /eos/project/c/cmsml4dc/ML_2020 . How to produce your own skimmed input files from the centrally provided csv files is still under discussion. The code to do so is available in this repository (if run on SWAN, which has direct access to EOS), but not in the executable file (which is run locally). To do: update documentation when other options are available.","title":"Input files"},{"location":"run/#the-histstruct-object","text":"The 'HistStruct' is the central object used in this program. It contains all relevant histograms (depending on the target run, training runs and histogram types) and their respective classifiers in a structured way. Selecting subsets of histograms, e.g. for classifier training or evaluation, is managed by using masks, which you can initialize when creating the HistStruct. There are three types of masks: - run masks: select lumisections belonging to a given run number. - statistics masks: select lumisections with high or low statistics. Currently the criterion is simply based on the number of histogram entries divided by the number of bins. Might be extended in the future. - json masks: select lumisections with a custom json file in the same format as the typical so-called golden json file. Any json file in the correct format can be uploaded, which allows full flexibility in selecting lumisections.","title":"The HistStruct object"},{"location":"run/#typical-workflow","text":"After having loaded or created a new HistStruct object, you can start the training and evaluation of histogram classifiers. A typical workflow would consist of (most of) the following steps: - preprocessing the histograms (i.e. rebinning, normalizing and/or cropping). See the 'Preprocessing' button. - make plots of the training set, target set and other histograms that might be relevant. See the 'Plotting' button. - resample the training set to increase statistics (might not be needed for some types of classifiers). See the 'Resampling' button. - adding classifiers for each histogram type. See the 'Add classifiers' button. - train all classifiers. See the 'Train classifiers' button. - fit a probability density function to the resulting classifier scores in order to get from a per-histogram score to a per-lumisection score. See the 'Fit' button. - evaluate the model. See 'Evaluate model' button. - take a closer look at some lumisections. For example in the case of an autoencoder one might be interested to compare the original histogram to its autoencoder reconstruction. Or more generally one could be interested to see what histogram types are causing the high lumisection score. See 'Plot lumisection' button.","title":"Typical workflow"},{"location":"run/#example-usage","text":"Some examples on how to use the GUI are put in slides and collected on this CERNBox location","title":"Example usage"},{"location":"runswan/","text":"Run the ML4DQM functionality using the GUI on SWAN How to start the program Simply download the repository and open the notebook nbgui.ipynb in SWAN. Downloading the repository See the README in the parent folder for more explanation. Dependencies: - All of the required dependencies are installed by default on SWAN! - To do: make list of optional dependencies that are not installed by default (e.g. imageio?) Where to start? The starting screen of the GUI shows a number of tabs for several actions one can perform. Usually one would start by loading a previously stored HistStruct (a structure containing all relevant histograms and classifiers) via the 'Load' tab, or create a new one via the 'New' tab. Many of the other tabs will not work if you have not loaded or created a valid HistStruct first. To create a HistStruct, the GUI expects input files in a specific format, see below. Input files Some example input files are provided on this CERNBox location . They are skimmed versions of the centrally provided (legacy) csv files with monintoring elements (both 1D and 2D histograms) with a per-lumisection granularity. The central files are available on EOS: /eos/project/c/cmsml4dc/ML_2020 . Starting from 2022 data-taking, nanoDQMIO files are supposed to be the main central input. They can however be preprocessed into small csv files fully compatible with the legacy ones. See the main README and the folder dqmio in this repository for more information. The HistStruct object The 'HistStruct' is the central object used in this program. It contains all relevant histograms (depending on the target run, training runs and histogram types) and their respective classifiers in a structured way. Selecting subsets of histograms, e.g. for classifier training or evaluation, is managed by using masks, which you can initialize when creating the HistStruct. There are three types of masks: - run masks: select lumisections belonging to a given run number. - statistics masks: select lumisections with high or low statistics. Currently the criterion is simply based on the number of histogram entries divided by the number of bins. Might be extended in the future. - json masks: select lumisections with a custom json file in the same format as the typical so-called golden json file. Any json file in the correct format can be uploaded, which allows full flexibility in selecting lumisections. Typical workflow After having loaded or created a new HistStruct object, you can start the training and evaluation of histogram classifiers. A typical workflow would consist of (most of) the following steps: - preprocessing the histograms (i.e. rebinning, normalizing and/or cropping). See the 'Preprocessing' button. - make plots of the training set, target set and other histograms that might be relevant. See the 'Plotting' button. - resample the training set to increase statistics (might not be needed for some types of classifiers). See the 'Resampling' button. - adding classifiers for each histogram type. See the 'Add classifiers' button. - train all classifiers. See the 'Train classifiers' button. - fit a probability density function to the resulting classifier scores in order to get from a per-histogram score to a per-lumisection score. See the 'Fit' button. - evaluate the model. See 'Evaluate model' button. - take a closer look at some lumisections. For example in the case of an autoencoder one might be interested to compare the original histogram to its autoencoder reconstruction. Or more generally one could be interested to see what histogram types are causing the high lumisection score. See 'Plot lumisection' button. Example usage Some examples on how to use the GUI are put in slides and collected on this CERNBox location . To do: update!","title":"README"},{"location":"runswan/#run-the-ml4dqm-functionality-using-the-gui-on-swan","text":"","title":"Run the ML4DQM functionality using the GUI on SWAN"},{"location":"runswan/#how-to-start-the-program","text":"Simply download the repository and open the notebook nbgui.ipynb in SWAN.","title":"How to start the program"},{"location":"runswan/#downloading-the-repository","text":"See the README in the parent folder for more explanation. Dependencies: - All of the required dependencies are installed by default on SWAN! - To do: make list of optional dependencies that are not installed by default (e.g. imageio?)","title":"Downloading the repository"},{"location":"runswan/#where-to-start","text":"The starting screen of the GUI shows a number of tabs for several actions one can perform. Usually one would start by loading a previously stored HistStruct (a structure containing all relevant histograms and classifiers) via the 'Load' tab, or create a new one via the 'New' tab. Many of the other tabs will not work if you have not loaded or created a valid HistStruct first. To create a HistStruct, the GUI expects input files in a specific format, see below.","title":"Where to start?"},{"location":"runswan/#input-files","text":"Some example input files are provided on this CERNBox location . They are skimmed versions of the centrally provided (legacy) csv files with monintoring elements (both 1D and 2D histograms) with a per-lumisection granularity. The central files are available on EOS: /eos/project/c/cmsml4dc/ML_2020 . Starting from 2022 data-taking, nanoDQMIO files are supposed to be the main central input. They can however be preprocessed into small csv files fully compatible with the legacy ones. See the main README and the folder dqmio in this repository for more information.","title":"Input files"},{"location":"runswan/#the-histstruct-object","text":"The 'HistStruct' is the central object used in this program. It contains all relevant histograms (depending on the target run, training runs and histogram types) and their respective classifiers in a structured way. Selecting subsets of histograms, e.g. for classifier training or evaluation, is managed by using masks, which you can initialize when creating the HistStruct. There are three types of masks: - run masks: select lumisections belonging to a given run number. - statistics masks: select lumisections with high or low statistics. Currently the criterion is simply based on the number of histogram entries divided by the number of bins. Might be extended in the future. - json masks: select lumisections with a custom json file in the same format as the typical so-called golden json file. Any json file in the correct format can be uploaded, which allows full flexibility in selecting lumisections.","title":"The HistStruct object"},{"location":"runswan/#typical-workflow","text":"After having loaded or created a new HistStruct object, you can start the training and evaluation of histogram classifiers. A typical workflow would consist of (most of) the following steps: - preprocessing the histograms (i.e. rebinning, normalizing and/or cropping). See the 'Preprocessing' button. - make plots of the training set, target set and other histograms that might be relevant. See the 'Plotting' button. - resample the training set to increase statistics (might not be needed for some types of classifiers). See the 'Resampling' button. - adding classifiers for each histogram type. See the 'Add classifiers' button. - train all classifiers. See the 'Train classifiers' button. - fit a probability density function to the resulting classifier scores in order to get from a per-histogram score to a per-lumisection score. See the 'Fit' button. - evaluate the model. See 'Evaluate model' button. - take a closer look at some lumisections. For example in the case of an autoencoder one might be interested to compare the original histogram to its autoencoder reconstruction. Or more generally one could be interested to see what histogram types are causing the high lumisection score. See 'Plot lumisection' button.","title":"Typical workflow"},{"location":"runswan/#example-usage","text":"Some examples on how to use the GUI are put in slides and collected on this CERNBox location . To do: update!","title":"Example usage"},{"location":"src/DataLoader/","text":"DataLoader Class for loading histograms from disk into a pandas dataframe. Typically, the input consists of a single file per histogram type, prepared from the nanoDQMIO format (accessed via DAS) and converted into another file format. see the tools in the 'dqmio' folder for more info on preparing the input files. Currently supported input file formats: - csv - parquet Example usage: from DataLoader import DataLoader dl = DataLoader() df = dl.get_dataframe_from_file( ) Alternatively, support is available to read the legacy per-LS csv files (deprecated approach for run-II data, before nanoDQMIO in run-III). In this case, the needed input consists of: - a set of histogram names to load - a specification in terms of eras or years Example usage: from DataLoader import DataLoader dl = DataLoader() csvfiles = dl.get_default_csv_files( year= , dim= ) df = dl.get_dataframe_from_files( csvfiles, histnames= ) The output consists of a pandas dataframe containing the requested histograms. [class] DataLoader comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self ) comments: initializer initialization of valid years and eras for which legacy csv files exist (note: only relevant for legacy csv approach, else empty initializer) \u2937 check_year full signature: def check_year( self, year ) comments: check if a provided year is valid (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - year: year in string format \u2937 check_eras full signature: def check_eras( self, eras, year ) comments: check if a list of provided eras is valid (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - eras: list of eras in string format, e.g. ['B','C'] - year: year in string format \u2937 check_dim full signature: def check_dim( self, dim ) comments: check if a histogram dimension is valid (note: only 1D and 2D histograms are supported for now) (note: internal helper function, no need to call) \u2937 check_eos full signature: def check_eos( self ) comments: check if the /eos directory exists and is accessible (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) \u2937 get_default_data_dirs full signature: def get_default_data_dirs( self, year='2017', eras=[], dim=1 ) comments: get the default data directories for the data for this project (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) note: this returns the directories where the data is currently stored; might change in future reprocessings of the data, and should be extended for upcoming Run-III data. note: default directories are on the /eos file system. this function will throw an exception if it does not have access to /eos. input arguments: - year: data-taking year, should be '2017' or '2018' so far (default: 2017) - eras: list of valid eras for the given data-taking year (default: all eras) - dim: dimension of requested histograms (1 or 2) note: need to provide the dimension at this stage since the files for 1D and 2D histograms are stored in different directories. returns: a list of directories containing the legacy csv files with the requested data. \u2937 get_csv_files_in_dir full signature: def get_csv_files_in_dir( self, inputdir, sort=True ) comments: get a (optionally sorted) list of csv files in a given input directory (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - inputdir: directory to scan for csv files - sort: boolean whether to sort the files returns: a list of csv files in the given directory. \u2937 get_csv_files_in_dirs full signature: def get_csv_files_in_dirs( self, inputdirs, sort=True ) comments: find the csv files in a set of input directories and return them in one list. (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) this function simply loops over the directories given in inputdirs, calls get_csv_files_in_dir for each of them, and concatenates the results. input arguments: - list of input directories where to look for csv files - sort: see get_csv_files_in_dir returns: a list of csv files in the given directories. \u2937 get_default_csv_files full signature: def get_default_csv_files( self, year='2017', eras=[], dim=1, sort=True ) comments: read the csv files from the default directories with input data for this project (note: only relevant for legacy csv approach) note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year, eras, dim: see get_default_data_dirs! - sort: see get_csv_files_in_dir! returns: a list of csv files with the data corresponding to the provided year, eras and dimension. \u2937 get_dataframe_from_file full signature: def get_dataframe_from_file( self, dfile, histnames=[], sort=True, verbose=True ) comments: load histograms from a given file into a dataframe input arguments: - dfile: file containing the data. currently supported formats: csv, parquet. - histnames: list of histogram names to keep (default: keep all histograms present in the input file). - sort: whether to sort the dataframe by run and lumisection number (note: requires keys 'fromrun' and 'fromlumi' to be present in the dataframe). - verbose: whether to print info messages. returns: a pandas dataframe \u2937 get_dataframe_from_files full signature: def get_dataframe_from_files( self, dfiles, histnames=[], sort=True, verbose=True ) comments: load histograms from a given set of files into a single dataframe input arguments: - dfiles: list of files containing the data. currently supported formats: csv, parquet. - histnames: list of histogram names to keep (default: keep all histograms present in the input file). - sort: whether to sort the dataframe by run and lumisection number (note: requires keys 'fromrun' and 'fromlumi' to be present in the dataframe). - verbose: whether to print info messages. returns: a pandas dataframe \u2937 write_dataframe_to_file full signature: def write_dataframe_to_file( self, df, dfile, overwrite=False, verbose=True ) comments: write a dataframe to a file input arguments: - df: a pandas dataframe. - dfile: file name to write. currently supported formats: csv, parquet. - overwrite: whether to overwrite if a file with the given name already exists. - verbose: whether to print info messages.","title":"DataLoader"},{"location":"src/DataLoader/#dataloader","text":"Class for loading histograms from disk into a pandas dataframe. Typically, the input consists of a single file per histogram type, prepared from the nanoDQMIO format (accessed via DAS) and converted into another file format. see the tools in the 'dqmio' folder for more info on preparing the input files. Currently supported input file formats: - csv - parquet Example usage: from DataLoader import DataLoader dl = DataLoader() df = dl.get_dataframe_from_file( ) Alternatively, support is available to read the legacy per-LS csv files (deprecated approach for run-II data, before nanoDQMIO in run-III). In this case, the needed input consists of: - a set of histogram names to load - a specification in terms of eras or years Example usage: from DataLoader import DataLoader dl = DataLoader() csvfiles = dl.get_default_csv_files( year= , dim= ) df = dl.get_dataframe_from_files( csvfiles, histnames= ) The output consists of a pandas dataframe containing the requested histograms.","title":"DataLoader"},{"location":"src/DataLoader/#class-dataloader","text":"comments: (no valid documentation found)","title":"[class] DataLoader"},{"location":"src/DataLoader/#9595init9595","text":"full signature: def __init__( self ) comments: initializer initialization of valid years and eras for which legacy csv files exist (note: only relevant for legacy csv approach, else empty initializer)","title":"&#10551; __init__"},{"location":"src/DataLoader/#check95year","text":"full signature: def check_year( self, year ) comments: check if a provided year is valid (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - year: year in string format","title":"&#10551; check_year"},{"location":"src/DataLoader/#check95eras","text":"full signature: def check_eras( self, eras, year ) comments: check if a list of provided eras is valid (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - eras: list of eras in string format, e.g. ['B','C'] - year: year in string format","title":"&#10551; check_eras"},{"location":"src/DataLoader/#check95dim","text":"full signature: def check_dim( self, dim ) comments: check if a histogram dimension is valid (note: only 1D and 2D histograms are supported for now) (note: internal helper function, no need to call)","title":"&#10551; check_dim"},{"location":"src/DataLoader/#check95eos","text":"full signature: def check_eos( self ) comments: check if the /eos directory exists and is accessible (note: only relevant for legacy csv approach) (note: internal helper function, no need to call)","title":"&#10551; check_eos"},{"location":"src/DataLoader/#get95default95data95dirs","text":"full signature: def get_default_data_dirs( self, year='2017', eras=[], dim=1 ) comments: get the default data directories for the data for this project (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) note: this returns the directories where the data is currently stored; might change in future reprocessings of the data, and should be extended for upcoming Run-III data. note: default directories are on the /eos file system. this function will throw an exception if it does not have access to /eos. input arguments: - year: data-taking year, should be '2017' or '2018' so far (default: 2017) - eras: list of valid eras for the given data-taking year (default: all eras) - dim: dimension of requested histograms (1 or 2) note: need to provide the dimension at this stage since the files for 1D and 2D histograms are stored in different directories. returns: a list of directories containing the legacy csv files with the requested data.","title":"&#10551; get_default_data_dirs"},{"location":"src/DataLoader/#get95csv95files95in95dir","text":"full signature: def get_csv_files_in_dir( self, inputdir, sort=True ) comments: get a (optionally sorted) list of csv files in a given input directory (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) input arguments: - inputdir: directory to scan for csv files - sort: boolean whether to sort the files returns: a list of csv files in the given directory.","title":"&#10551; get_csv_files_in_dir"},{"location":"src/DataLoader/#get95csv95files95in95dirs","text":"full signature: def get_csv_files_in_dirs( self, inputdirs, sort=True ) comments: find the csv files in a set of input directories and return them in one list. (note: only relevant for legacy csv approach) (note: internal helper function, no need to call) this function simply loops over the directories given in inputdirs, calls get_csv_files_in_dir for each of them, and concatenates the results. input arguments: - list of input directories where to look for csv files - sort: see get_csv_files_in_dir returns: a list of csv files in the given directories.","title":"&#10551; get_csv_files_in_dirs"},{"location":"src/DataLoader/#get95default95csv95files","text":"full signature: def get_default_csv_files( self, year='2017', eras=[], dim=1, sort=True ) comments: read the csv files from the default directories with input data for this project (note: only relevant for legacy csv approach) note: default directories are on the /eos file system. this function will throw an exception if it has not access to /eos. input arguments: - year, eras, dim: see get_default_data_dirs! - sort: see get_csv_files_in_dir! returns: a list of csv files with the data corresponding to the provided year, eras and dimension.","title":"&#10551; get_default_csv_files"},{"location":"src/DataLoader/#get95dataframe95from95file","text":"full signature: def get_dataframe_from_file( self, dfile, histnames=[], sort=True, verbose=True ) comments: load histograms from a given file into a dataframe input arguments: - dfile: file containing the data. currently supported formats: csv, parquet. - histnames: list of histogram names to keep (default: keep all histograms present in the input file). - sort: whether to sort the dataframe by run and lumisection number (note: requires keys 'fromrun' and 'fromlumi' to be present in the dataframe). - verbose: whether to print info messages. returns: a pandas dataframe","title":"&#10551; get_dataframe_from_file"},{"location":"src/DataLoader/#get95dataframe95from95files","text":"full signature: def get_dataframe_from_files( self, dfiles, histnames=[], sort=True, verbose=True ) comments: load histograms from a given set of files into a single dataframe input arguments: - dfiles: list of files containing the data. currently supported formats: csv, parquet. - histnames: list of histogram names to keep (default: keep all histograms present in the input file). - sort: whether to sort the dataframe by run and lumisection number (note: requires keys 'fromrun' and 'fromlumi' to be present in the dataframe). - verbose: whether to print info messages. returns: a pandas dataframe","title":"&#10551; get_dataframe_from_files"},{"location":"src/DataLoader/#write95dataframe95to95file","text":"full signature: def write_dataframe_to_file( self, df, dfile, overwrite=False, verbose=True ) comments: write a dataframe to a file input arguments: - df: a pandas dataframe. - dfile: file name to write. currently supported formats: csv, parquet. - overwrite: whether to overwrite if a file with the given name already exists. - verbose: whether to print info messages.","title":"&#10551; write_dataframe_to_file"},{"location":"src/HistStruct/","text":"HistStruct HistStruct: consistent treatment of multiple histogram types The HistStruct class is the main data structure used within this framework. A HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). The HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a custom or predefined json file formatted selector), - prepare the data for machine learning training, with all kinds of preprocessing, - evaluate classifiers (machine learning types or other), - go from per-histogram scores to per-lumisection scores. When only processing a single histogram type, the HistStruct might be a bit of an overkill. One could instead choose to operate on the dataframe directly. However, especially when using multiple histogram types, the HistStruct is very handy to keep everything consistent. [class] HistStruct comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self ) comments: empty initializer, setting all containers to empty defaults a HistStruct object has the following properties: histnames: list of histogram names histograms: dict mapping histogram name to 2D numpy array of histograms (shape (nhists,nbins)) nentries: dict mapping histogram name to 1D numpy array of number of entries per histogram (same length as histograms) histranges: dict mapping histogram name to tuple with (xmin, xmax) runnbs: 1D numpy array of run numbers (same length as histograms) lsnbs: 1D numpy array of lumisection numbers (same length as histograms) masks: dict mapping name to 1D numpy array of booleans (same length as histograms) that can be used for masking exthistograms: dict of dicts similar to histograms for additional (e.g. artificially generated) histograms setnames: list of names of extended sets models: dict mapping model names to ModelInterfaces modelnames: list of model names \u2937 __str__ full signature: def __str__( self ) comments: get a printable representation of a HistStruct \u2937 save full signature: def save( self, path, save_models=False, save_classifiers=True, save_fitter=True ) comments: save a HistStruct object to a pkl file input arguments: - path where to store the file (appendix .zip is automatically appended) - save_models: a boolean whether to include the models if present in the HistStruct - save_classifiers: a boolean whether to include the classifiers if present in the ModelInterfaces - save_fitter: a boolean whether to include the fitter if present in the ModelInterfaces \u2937 load full signature: def load( self, path, load_models=True, load_classifiers=True, load_fitter=True, verbose=False ) comments: load a HistStruct object input arguments: - path to a zip file containing a HistStruct object - load_models: a boolean whether to load the models if present - load_classifiers: a boolean whether to load the classifiers if present - load_fitter: a boolean whether to load the fitter if present - verbose: boolean whether to print some information \u2937 add_dataframe full signature: def add_dataframe( self, df, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True ) comments: add a dataframe to a HistStruct input arguments: - df: a pandas dataframe as read from the input csv files - cropslices: list of slices (one per dimension) by which to crop the histograms see hist_utils.py / crophists for more info. - rebinningfactor: factor by which to group bins together see hist_utils.py / rebinhists for more info. - smoothinghalfwindow: half window (int for 1D, tuple for 2D) for doing smoothing of histograms - smoothingweights: weight array (1D for 1D, 2D for 2D) for smoothing of histograms see hist_utils.py / smoothhists for more info. - averagewindow: window (int or tuple) for averaging each histogram with its neighbours - averageweights: weights for averaging each histogram with its neighbours see hist_utils.py / running_average_hists for more info. - donormalize: boolean whether to normalize the histograms see hist_utils.py / normalizehists for more info. notes: - the new dataframe can contain one or multiple histogram types - the new dataframe must contain the same run and lumisection numbers (for each histogram type in it) as already present in the HistStruct, except if it is the first one to be added - alternative to adding the dataframe with the preprocessing options, one can also apply the preprocessing at a later stage using the preprocess() function with the same arguments. \u2937 add_histograms full signature: def add_histograms( self, histname, histograms, runnbs, lsnbs, nentries=None ) comments: add a set of histograms to a HistStruct input arguments: - histname: name of the histogram type to be added - histograms: a numpy array of shape (nhistograms,nbins), assumed to be of a single type - runnbs: a 1D list or array of length nhistograms containing the run number per histogram - lsnbs: a 1D list or array of length nhistograms containing the lumisection number per histogram - nentries: a 1D list or array of length nhistograms containing the number of entries per histogram notes: - must be provided explicitly since histograms might be normalized, in which case the number of entries cannot be determined from the sum of bin contents. - used for (de-)selecting histograms with sufficient statistics; if you don't need that type of selection, nentries can be left at default. - default is None, meaning all entries will be set to zero. notes: - no preprocessing is performed, this is assumed to have been done manually (if needed) before adding the histograms - runnbs and lsnbs must correspond to what is already in the current HistStruct, except if this is the first set of histogram to be added - see also add_dataframe for an alternative way of adding histograms \u2937 preprocess full signature: def preprocess( self, masknames=None, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=False ) comments: do preprocessing input arguments: - masknames: names of masks to select histograms to which to apply the preprocessing (histograms not passing the masks are simply copied) the other input arguments are equivalent to those given in add_dataframe, but this function allows to do preprocessing after the dataframes have already been loaded note: does not work on extended histograms sets! one needs to apply preprocessing before generating extra histograms. \u2937 add_globalscores full signature: def add_globalscores( self, globalscores ) comments: add an array of global scores (one per lumisection) DEPRECATED, DO NOT USE ANYMORE input arguments: - globalscores: 1D numpy array of scores (must have same length as lumisection and run numbers) \u2937 add_extglobalscores full signature: def add_extglobalscores( self, extname, globalscores ) comments: add an array of global scores (one per lumisection) for a specified extra set of histograms in the HistStruct DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of extra histogram set - globalscores: 1D numpy array of scores note: this function checks if all histogram types in this set contain the same number of histograms, (and that this number corresponds to the length of globalscores) else adding globalscores is meaningless \u2937 add_exthistograms full signature: def add_exthistograms( self, setname, histname, histograms, overwrite=False ) comments: add a set of extra histograms to a HistStruct these histograms are not assumed to correspond to physical run/lumisections numbers (e.g. resampled ones), and no consistency checks are done input arguments: - setname: name of the extra histogram set (you can add multiple, e.g. resampled_good, resampled_bad and/or resampled_training) - histname: name of the histogram type - histograms: a numpy array of shape (nhistograms,nbins) - overwrite: boolean whether to overwrite a set of histograms of the same name if present (default: raise exception) \u2937 add_mask full signature: def add_mask( self, name, mask ) comments: add a mask to a HistStruct input arguments: - name: a name for the mask - mask: a 1D np array of booleans with same length as number of lumisections in HistStruct \u2937 remove_mask full signature: def remove_mask( self, name ) comments: inverse operation of add_mask \u2937 add_index_mask full signature: def add_index_mask( self, name, indices ) comments: add a mask corresponding to predefined indices input arguments: - name: a name for the mask - indices: a 1D np array of integer indices, between 0 and the number of lumisections in HistStruct \u2937 add_run_mask full signature: def add_run_mask( self, name, runnb ) comments: add a mask corresponding to a given run number input arguments: - name: a name for the mask - runnb: run number \u2937 add_multirun_mask full signature: def add_multirun_mask( self, name, runnbs ) comments: add a mask corresponding to a given list of run numbers input arguments: - name: a name for the mask - runnbs: a list of run numbers \u2937 add_json_mask full signature: def add_json_mask( self, name, jsondict ) comments: add a mask corresponding to a json dict input arguments: - name: a name for the mask - jsondict: a dictionary in typical json format (see the golden json file for inspiration) all lumisections present in the jsondict will be masked True, the others False. \u2937 add_goldenjson_mask full signature: def add_goldenjson_mask( self, name ) comments: add a mask corresponding to the golden json file input arguments: - name: a name for the mask \u2937 add_dcsonjson_mask full signature: def add_dcsonjson_mask( self, name ) comments: add a mask corresponding to the DCS-bit on json file input arguments: - name: a name for the mask \u2937 add_stat_mask full signature: def add_stat_mask( self, name, histnames=None, min_entries_to_bins_ratio=-1, max_entries_to_bins_ratio=-1 ) comments: add a mask corresponding to lumisections where all histograms have statistics within given bounds input arguments: - histnames: list of histogram names to take into account for making the mask (default: all in the HistStruct) - min_entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics (default: no lower boundary) - max_entries_to_bins_ratio: same but upper boundary instead of lower boundary (default: no upper boundary) \u2937 add_highstat_mask full signature: def add_highstat_mask( self, name, histnames=None, entries_to_bins_ratio=100 ) comments: shorthand call to add_stat_mask with only lower boundary and no upper boundary for statistics input arguments: - entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics others: see add_stat_mask \u2937 pass_masks full signature: def pass_masks( self, masknames, runnbs=None, lsnbs=None ) comments: get a list of booleans of lumisections whether they pass a given set of masks input arguments: - masknames: list of mask names - runnbs: list of run numbers (default: all in histstruct) - lsnbs: list of lumisection numbers (equally long as runnbs) (default: al in histstruct) \u2937 get_masknames full signature: def get_masknames( self ) comments: return a list of all mask names in the current HistStruct \u2937 get_mask full signature: def get_mask( self, name ) comments: return a mask in the current HistStruct \u2937 get_combined_mask full signature: def get_combined_mask( self, names ) comments: get a combined (intersection) mask given multiple mask names mostly for internal use; externally you can use get_histograms( histname, <list of mask names>) directly \u2937 get_union_mask full signature: def get_union_mask( self, names ) comments: get a combined (union) mask given multiple mask names mostly for internal use \u2937 get_runnbs full signature: def get_runnbs( self, masknames=None ) comments: get the array of run numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) \u2937 get_runnbs_unique full signature: def get_runnbs_unique( self, masknames=None ) comments: get a list of unique run numbers \u2937 get_lsnbs full signature: def get_lsnbs( self, masknames=None ) comments: get the array of lumisection numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array) \u2937 get_index full signature: def get_index( self, runnb, lsnb ) comments: get the index in the current HistStruct of a given run and lumisection number input arguments: - runnb and lsnb: run and lumisection number respectively \u2937 get_scores full signature: def get_scores( self, modelname, histname=None, setnames=None, masknames=None ) comments: get the array of scores for a given model and for a given histogram type, optionally after masking input arguments: - modelname: name of the model for which to retrieve the scores - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores - setnames: list of names of the histogram sets (use None for standard set) - masknames: list of names of masks (default: no masking, return full array) notes: - do not use setnames and masknames simultaneously, this is not defined - if multiple masks are given, the intersection is taken; if multiple sets are given, the union is taken - the classifiers in the appropriate model must have been evaluated before calling this method! \u2937 get_scores_array full signature: def get_scores_array( self, modelname, setnames=None, masknames=None ) comments: similar to get_scores, but with different return type: np array of shape (nhistograms, nhistogramtypes) \u2937 get_extscores full signature: def get_extscores( self, extname, histname=None ) comments: get the array of scores for a given histogram type in a given extra set. DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of the extra set (see also add_exthistograms) - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores notes: - this method takes the scores from the HistStruct.extscores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown. \u2937 get_extscores_array full signature: def get_extscores_array( self, extname ) comments: similar to get_extscores, but with different return type: np array of shape (nhistograms, nhistogramtypes) DEPRECATED, DO NOT USE ANYMORE \u2937 get_scores_ls full signature: def get_scores_ls( self, modelname, runnb, lsnb, histnames=None ) comments: get the scores for a given run/lumisection number and for given histogram names input arguments: - modelname: name of the model for which to retrieve the score - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) \u2937 get_globalscores full signature: def get_globalscores( self, modelname, setnames=None, masknames=None ) comments: get the array of global scores, optionally after masking input arguments: - modelname: name of the model for which to retrieve the global score - setnames: list of names of the histogram sets (use None for standard set) - masknames: list of names of masks (default: no masking, return full array) notes: - do not use setnames and masknames simultaneously, this is not defined - if multiple masks are given, the intersection is taken; if multiple sets are given, the union is taken - the classifiers in the appropriate model must have been evaluated before calling this method! \u2937 get_globalscores_jsonformat full signature: def get_globalscores_jsonformat( self, modelname=None ) comments: make a json format listing all lumisections in this histstruct the output list has entries for global scores and masks input arguments: - modelname: name of the model for wich to retrieve the global score if None, all available models will be used \u2937 get_globalscore_ls full signature: def get_globalscore_ls( self, modelname, runnb, lsnb ) comments: get the global score for a given run/lumisection number input arguments: - modelname: name of the model for which to retrieve the global score - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score) \u2937 get_globalscores_mask full signature: def get_globalscores_mask( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the mask for global score between specified boundaries input arguments: - modelname: name of the model for which to consider the global scores - masknames: list of additional masks (on top of score boundaries) to consider - setnames: list of set names for which to retrieve the global scores - score_up and score_down are upper and lower thresholds if both are not None, the mask for global scores between the boundaries are returned if score_up is None, the mask for global score > score_down are returned if score_down is None, the mask for global score < score_up are returned \u2937 get_globalscores_indices full signature: def get_globalscores_indices( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the indices with a global score between specified boundaries input arguments: see get_globalscore_mask \u2937 get_globalscores_runsls full signature: def get_globalscores_runsls( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the run and lumisection numbers with a global score between specified boundaries input arguments: see get_globalscore_mask \u2937 get_extglobalscores full signature: def get_extglobalscores( self, extname ) comments: get the array of global scores for one of the extra histogram sets DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of the extra histogram set notes: - this method takes the scores from the HistStruct.extglobalscores attribute; make sure to have set this attribute with add_extglobalscores, else an exception will be thrown. \u2937 get_histograms full signature: def get_histograms( self, histname=None, masknames=None, setnames=None ) comments: get the array of histograms for a given type, optionally after masking input arguments: - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms - masknames: list of names of masks (default: no masking, return full array) - setnames: list of names of the sets of extra histograms (see also add_exthistograms) if multiple setnames are provided, the union/concatenation is returned \u2937 get_histogramsandscores full signature: def get_histogramsandscores( self, modelname=None, setnames=None, masknames=None, nrandoms=-1, nfirst=-1 ) comments: combination of get_histograms, get_scores and get_globalscores with additional options - modelname: name of the model for which to retrieve the score if None, no scores will be retrieved (only histograms) - setnames: list of names of histogram sets (use None for default set) - masknames: list of names of masks - nrandoms: if > 0, number of random instances to draw - nfirst: if > 0, number of first instances to keep return type: dict with keys 'histograms', 'scores' and 'globalscores' note that the values of scores and globalscores may be None if not initialized \u2937 add_model full signature: def add_model( self, modelname, model ) comments: add a model to the HistStruct input arguments: - modelname: a name for the model - model: an instance of ModelInterface class with histnames corresponding to the ones for this HistStruct \u2937 check_model full signature: def check_model( self, modelname ) comments: check if a given model name is present in the HistStruct input arguments: - modelname: name of the model to check \u2937 remove_model full signature: def remove_model( self, modelname ) comments: remove a model input arguments: - modelname: name of the model to remove \u2937 train_classifier full signature: def train_classifier( self, modelname, histname, masknames=None, setnames=None, **kwargs ) comments: train a histogram classifier input arguments: - modelname: name of the model for which to train the classifiers - histname: a valid histogram name present in the HistStruct for which to train the classifier - masknames: list of masks the classifiers should be trained on - setnames: list of names of sets of extra histograms on which the classifiers should be trained - kwargs: additional keyword arguments for training \u2937 train_classifiers full signature: def train_classifiers( self, modelname, masknames=None, setnames=None, **kwargs ) comments: train histogram classifiers for all histogram types input arguments: - modelname: name of the model for which to train the classifiers - masknames: list of masks the classifiers should be trained on - setnames: list of names of sets of extra histograms on which the classifiers should be trained - kwargs: additional keyword arguments for training \u2937 evaluate_classifier full signature: def evaluate_classifier( self, modelname, histname, masknames=None, setnames=None ) comments: evaluate a histogram classifier input arguments: - modelname: name of the model for wich to evaluate the classifiers - histname: a valid histogram name present in the HistStruct for which to evaluate the classifier - masknames: list of masks if the classifiers should be evaluated on a subset only (e.g. for speed) - setnames: list of names of sets of extra histograms for which the classifiers should be evaluated \u2937 evaluate_classifiers full signature: def evaluate_classifiers( self, modelname, masknames=None, setnames=None ) comments: evaluate histogram classifiers for all histogram types input arguments: - modelname: name of the model for wich to evaluate the classifiers - masknames: list of masks if the classifiers should be evaluated on a subset only (e.g. for speed) - setnames: list of names of a set of extra histograms for which the classifiers should be evaluated \u2937 set_fitter full signature: def set_fitter( self, modelname, fitter ) comments: set the fitter for a given model \u2937 train_fitter full signature: def train_fitter( self, modelname, masknames=None, setnames=None, verbose=False, **kwargs ) comments: train the fitter for a given model input arguments: - modelname: name of the model to train - masknames: list of mask names for training set - setnames: list of set names for training set - kwargs: additional keyword arguments for fitting note: use either masksnames or setnames, not both! \u2937 train_partial_fitters full signature: def train_partial_fitters( self, modelname, dimslist, masknames=None, setnames=None, **kwargs ) comments: train partial fitters for a given model input arguments: - modelname: name of the model to train - dimslist: list of tuples with integer dimension numbers - masknames: list of mask names for training set - setnames: list of set names for training set - kwargs: additional keyword arguments for fitting note: use either masksnames or setnames, not both! note: see also plot_partial_fit for a convenient plotting method! \u2937 evaluate_fitter full signature: def evaluate_fitter( self, modelname, masknames=None, setnames=None, verbose=False ) comments: evaluate the fitter for a given model input arguments: - modelname: name of the model for which to evaluate the fitter - masknames: list of mask names if the fitter should be evaluated on a subset only (e.g. for speed) - setnames: list of set names of extra histograms for which the fitter should be evaluated \u2937 evaluate_fitter_on_point full signature: def evaluate_fitter_on_point( self, modelname, point ) comments: evaluate the fitter on a given points input arguments: - modelname: name of the model for which to evaluate the fitter - points: dict matching histnames to scores (one float per histogram type) (e.g. as returned by get_scores_ls) returns: - the global score for the provided point (a float) \u2937 evaluate_fitter_on_points full signature: def evaluate_fitter_on_points( self, modelname, points ) comments: evaluate the fitter on a given set of points input arguments: - modelname: name of the model for which to evaluate the fitter - points: dict matching histnames to scores (np array of shape (nhistograms)) returns: - the global scores for the provided points \u2937 plot_histograms full signature: def plot_histograms( self, histnames=None, masknames=None, histograms=None, ncols=4, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a HistStruct, optionally after masking input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list of list of mask names note: each element in masknames represents a set of masks to apply; the histograms passing different sets of masks are plotted in different colors - histograms: list of dicts of histnames to 2D arrays of histograms, can be used to plot a given collection of histograms directly, and bypass the histnames and masknames arguments (note: for use in the gui, not recommended outside of it) - ncols: number of columns (only relevant for 1D histograms) - colorlist: list of matplotlib colors, must have same length as masknames - labellist: list of labels for the legend, must have same legnth as masknames - transparencylist: list of transparency values, must have same length as masknames - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets \u2937 plot_histograms_1d full signature: def plot_histograms_1d( self, histnames=None, masknames=None, histograms=None, ncols=4, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms \u2937 plot_histograms_2d full signature: def plot_histograms_2d( self, histnames=None, masknames=None, histograms=None, labellist=[], titledict=None, xaxtitledict=None, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms \u2937 plot_histograms_run full signature: def plot_histograms_run( self, histnames=None, masknames=None, histograms=None, ncols=4, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot a set of histograms in a HistStruct with a smooth color gradient. typical use case: plot a single run. note: only for 1D histograms! input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list mask names (typically should contain a run number mask) - histograms: dict of histnames to 2D arrays of histograms, can be used to plot a given collection of histograms directly, and bypass the histnames and masknames arguments (note: for use in the gui, not recommended outside of it. - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_hists_multi \u2937 plot_histograms_run_1d full signature: def plot_histograms_run_1d( self, histnames=None, masknames=None, histograms=None, ncols=4, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms_run \u2937 plot_ls full signature: def plot_ls( self, runnb, lsnb, histnames=None, histlabel=None, ncols=4, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of histogram types to plot (default: all) - histlabel: legend entry for the histogram (default: run and lumisection number) - recohist: dict matching histogram names to reconstructed histograms notes: - 'reconstructed histograms' refers to e.g. autoencoder or NMF reconstructions; some models (e.g. simply looking at histogram moments) might not have this kind of reconstruction - in principle one histogram per key is expected, but still the the shape must be 2D (i.e. (1,nbins)) - in case recohist is set to a valid model name present in the current HistStruct, the reconstruction is calculated on the fly for the input histograms - recohistlabel: legend entry for the reco histograms - refhists: dict matching histogram names to reference histograms notes: - multiple histograms (i.e. a 2D array) per key are expected; in case there is only one reference histogram, it must be reshaped into (1,nbins) - refhistslabel: legend entry for the reference histograms - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets \u2937 plot_run full signature: def plot_run( self, runnb, masknames=None, ncols=4, recohist=None, recohistlabel='reco', refhists=None, refhistslabel='reference', doprint=False) comments: call plot_ls for all lumisections in a given run \u2937 plot_ls_1d full signature: def plot_ls_1d( self, runnb, lsnb, histnames=None, histlabel=None, ncols=4, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction internal helper function, use only via plot_ls [class] classifier = self.models[recohist].classifiers[name] comments: (no valid documentation found) \u2937 plot_ls_2d full signature: def plot_ls_2d( self, runnb, lsnb, histnames=None, histlabel=None, recohist=None, recohistlabel='Reconstruction', titledict=None, xaxtitledict=None, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their reconstruction internal helper function, use only via plot_ls [class] classifier = self.models[recohist].classifiers[name] comments: (no valid documentation found) \u2937 plot_ls_score full signature: def plot_ls_score( self, modelname, runnb, lsnb, ncols=4, masknames=None, setnames=None, **kwargs ) comments: plot the score of a given lumisection for each histogram type compared to reference scores input arguments: - modelname: name of the model for which to retrieve the score - runnb: run number - lsnb: lumisection number - masknames: list of mask names for the reference scores - setnames: list of set names for the reference scores - kwargs: additional keyword arguments passed down to pu.plot_score_dist \u2937 plot_partial_fit full signature: def plot_partial_fit( self, modelname, dims, clusters, **kwargs) comments: plot a partial fit calculated with train_partial_fitters input arguments: - modelname: name of the model for which to plot the partial fits - dims: a tuple of length 1 or 2 with integer dimension indices note: the partial fit for this dimension must have been calculated with train_partial_fitters first - clusters: a list of the different point clusters to plot each element in the list should be a dict of the form {'masknames': [list of mask names]} or {'setnames': [list of set names]} - kwargs: plot options passed down to pu.plot_fit_1d_clusters or pu.plot_fit_2d_clusters; some of them have to have the same length as clusters (e.g. colors and labels) \u2937 plot_score_dist full signature: def plot_score_dist( self, modelname, histname=None, masknames_sig=None, setnames_sig=None, masknames_bkg=None, setnames_bkg=None, **kwargs ) comments: plot a 1D score distribution input arguments: - modelname: name of the model for which to retrieve the scores - histname: type of histogram for which to retrieve the scores if None, the global scores will be retrieved - masknames_sig, setnames_sig: lists of mask or set names for signal distribution - masknames_bkg, setnames_bkg: lists of mask or set names for background distribution note: in case of multiple masks, the intersection is taken (as usual); in case of multiple sets, the union is taken! - kwargs: additional keyword arguments passed down to pu.plot_score_dist","title":"HistStruct"},{"location":"src/HistStruct/#histstruct","text":"HistStruct: consistent treatment of multiple histogram types The HistStruct class is the main data structure used within this framework. A HistStruct object basically consists of a mutually consistent collection of numpy arrays, where each numpy array corresponds to one histogram type, with dimensions (number of histograms, number of bins). The HistStruct has functions to easily perform the following common tasks (among others): - select a subset of runs and/or lumisections (e.g. using a custom or predefined json file formatted selector), - prepare the data for machine learning training, with all kinds of preprocessing, - evaluate classifiers (machine learning types or other), - go from per-histogram scores to per-lumisection scores. When only processing a single histogram type, the HistStruct might be a bit of an overkill. One could instead choose to operate on the dataframe directly. However, especially when using multiple histogram types, the HistStruct is very handy to keep everything consistent.","title":"HistStruct"},{"location":"src/HistStruct/#class-histstruct","text":"comments: (no valid documentation found)","title":"[class] HistStruct"},{"location":"src/HistStruct/#9595init9595","text":"full signature: def __init__( self ) comments: empty initializer, setting all containers to empty defaults a HistStruct object has the following properties: histnames: list of histogram names histograms: dict mapping histogram name to 2D numpy array of histograms (shape (nhists,nbins)) nentries: dict mapping histogram name to 1D numpy array of number of entries per histogram (same length as histograms) histranges: dict mapping histogram name to tuple with (xmin, xmax) runnbs: 1D numpy array of run numbers (same length as histograms) lsnbs: 1D numpy array of lumisection numbers (same length as histograms) masks: dict mapping name to 1D numpy array of booleans (same length as histograms) that can be used for masking exthistograms: dict of dicts similar to histograms for additional (e.g. artificially generated) histograms setnames: list of names of extended sets models: dict mapping model names to ModelInterfaces modelnames: list of model names","title":"&#10551; __init__"},{"location":"src/HistStruct/#9595str9595","text":"full signature: def __str__( self ) comments: get a printable representation of a HistStruct","title":"&#10551; __str__"},{"location":"src/HistStruct/#save","text":"full signature: def save( self, path, save_models=False, save_classifiers=True, save_fitter=True ) comments: save a HistStruct object to a pkl file input arguments: - path where to store the file (appendix .zip is automatically appended) - save_models: a boolean whether to include the models if present in the HistStruct - save_classifiers: a boolean whether to include the classifiers if present in the ModelInterfaces - save_fitter: a boolean whether to include the fitter if present in the ModelInterfaces","title":"&#10551; save"},{"location":"src/HistStruct/#load","text":"full signature: def load( self, path, load_models=True, load_classifiers=True, load_fitter=True, verbose=False ) comments: load a HistStruct object input arguments: - path to a zip file containing a HistStruct object - load_models: a boolean whether to load the models if present - load_classifiers: a boolean whether to load the classifiers if present - load_fitter: a boolean whether to load the fitter if present - verbose: boolean whether to print some information","title":"&#10551; load"},{"location":"src/HistStruct/#add95dataframe","text":"full signature: def add_dataframe( self, df, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True ) comments: add a dataframe to a HistStruct input arguments: - df: a pandas dataframe as read from the input csv files - cropslices: list of slices (one per dimension) by which to crop the histograms see hist_utils.py / crophists for more info. - rebinningfactor: factor by which to group bins together see hist_utils.py / rebinhists for more info. - smoothinghalfwindow: half window (int for 1D, tuple for 2D) for doing smoothing of histograms - smoothingweights: weight array (1D for 1D, 2D for 2D) for smoothing of histograms see hist_utils.py / smoothhists for more info. - averagewindow: window (int or tuple) for averaging each histogram with its neighbours - averageweights: weights for averaging each histogram with its neighbours see hist_utils.py / running_average_hists for more info. - donormalize: boolean whether to normalize the histograms see hist_utils.py / normalizehists for more info. notes: - the new dataframe can contain one or multiple histogram types - the new dataframe must contain the same run and lumisection numbers (for each histogram type in it) as already present in the HistStruct, except if it is the first one to be added - alternative to adding the dataframe with the preprocessing options, one can also apply the preprocessing at a later stage using the preprocess() function with the same arguments.","title":"&#10551; add_dataframe"},{"location":"src/HistStruct/#add95histograms","text":"full signature: def add_histograms( self, histname, histograms, runnbs, lsnbs, nentries=None ) comments: add a set of histograms to a HistStruct input arguments: - histname: name of the histogram type to be added - histograms: a numpy array of shape (nhistograms,nbins), assumed to be of a single type - runnbs: a 1D list or array of length nhistograms containing the run number per histogram - lsnbs: a 1D list or array of length nhistograms containing the lumisection number per histogram - nentries: a 1D list or array of length nhistograms containing the number of entries per histogram notes: - must be provided explicitly since histograms might be normalized, in which case the number of entries cannot be determined from the sum of bin contents. - used for (de-)selecting histograms with sufficient statistics; if you don't need that type of selection, nentries can be left at default. - default is None, meaning all entries will be set to zero. notes: - no preprocessing is performed, this is assumed to have been done manually (if needed) before adding the histograms - runnbs and lsnbs must correspond to what is already in the current HistStruct, except if this is the first set of histogram to be added - see also add_dataframe for an alternative way of adding histograms","title":"&#10551; add_histograms"},{"location":"src/HistStruct/#preprocess","text":"full signature: def preprocess( self, masknames=None, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=False ) comments: do preprocessing input arguments: - masknames: names of masks to select histograms to which to apply the preprocessing (histograms not passing the masks are simply copied) the other input arguments are equivalent to those given in add_dataframe, but this function allows to do preprocessing after the dataframes have already been loaded note: does not work on extended histograms sets! one needs to apply preprocessing before generating extra histograms.","title":"&#10551; preprocess"},{"location":"src/HistStruct/#add95globalscores","text":"full signature: def add_globalscores( self, globalscores ) comments: add an array of global scores (one per lumisection) DEPRECATED, DO NOT USE ANYMORE input arguments: - globalscores: 1D numpy array of scores (must have same length as lumisection and run numbers)","title":"&#10551; add_globalscores"},{"location":"src/HistStruct/#add95extglobalscores","text":"full signature: def add_extglobalscores( self, extname, globalscores ) comments: add an array of global scores (one per lumisection) for a specified extra set of histograms in the HistStruct DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of extra histogram set - globalscores: 1D numpy array of scores note: this function checks if all histogram types in this set contain the same number of histograms, (and that this number corresponds to the length of globalscores) else adding globalscores is meaningless","title":"&#10551; add_extglobalscores"},{"location":"src/HistStruct/#add95exthistograms","text":"full signature: def add_exthistograms( self, setname, histname, histograms, overwrite=False ) comments: add a set of extra histograms to a HistStruct these histograms are not assumed to correspond to physical run/lumisections numbers (e.g. resampled ones), and no consistency checks are done input arguments: - setname: name of the extra histogram set (you can add multiple, e.g. resampled_good, resampled_bad and/or resampled_training) - histname: name of the histogram type - histograms: a numpy array of shape (nhistograms,nbins) - overwrite: boolean whether to overwrite a set of histograms of the same name if present (default: raise exception)","title":"&#10551; add_exthistograms"},{"location":"src/HistStruct/#add95mask","text":"full signature: def add_mask( self, name, mask ) comments: add a mask to a HistStruct input arguments: - name: a name for the mask - mask: a 1D np array of booleans with same length as number of lumisections in HistStruct","title":"&#10551; add_mask"},{"location":"src/HistStruct/#remove95mask","text":"full signature: def remove_mask( self, name ) comments: inverse operation of add_mask","title":"&#10551; remove_mask"},{"location":"src/HistStruct/#add95index95mask","text":"full signature: def add_index_mask( self, name, indices ) comments: add a mask corresponding to predefined indices input arguments: - name: a name for the mask - indices: a 1D np array of integer indices, between 0 and the number of lumisections in HistStruct","title":"&#10551; add_index_mask"},{"location":"src/HistStruct/#add95run95mask","text":"full signature: def add_run_mask( self, name, runnb ) comments: add a mask corresponding to a given run number input arguments: - name: a name for the mask - runnb: run number","title":"&#10551; add_run_mask"},{"location":"src/HistStruct/#add95multirun95mask","text":"full signature: def add_multirun_mask( self, name, runnbs ) comments: add a mask corresponding to a given list of run numbers input arguments: - name: a name for the mask - runnbs: a list of run numbers","title":"&#10551; add_multirun_mask"},{"location":"src/HistStruct/#add95json95mask","text":"full signature: def add_json_mask( self, name, jsondict ) comments: add a mask corresponding to a json dict input arguments: - name: a name for the mask - jsondict: a dictionary in typical json format (see the golden json file for inspiration) all lumisections present in the jsondict will be masked True, the others False.","title":"&#10551; add_json_mask"},{"location":"src/HistStruct/#add95goldenjson95mask","text":"full signature: def add_goldenjson_mask( self, name ) comments: add a mask corresponding to the golden json file input arguments: - name: a name for the mask","title":"&#10551; add_goldenjson_mask"},{"location":"src/HistStruct/#add95dcsonjson95mask","text":"full signature: def add_dcsonjson_mask( self, name ) comments: add a mask corresponding to the DCS-bit on json file input arguments: - name: a name for the mask","title":"&#10551; add_dcsonjson_mask"},{"location":"src/HistStruct/#add95stat95mask","text":"full signature: def add_stat_mask( self, name, histnames=None, min_entries_to_bins_ratio=-1, max_entries_to_bins_ratio=-1 ) comments: add a mask corresponding to lumisections where all histograms have statistics within given bounds input arguments: - histnames: list of histogram names to take into account for making the mask (default: all in the HistStruct) - min_entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics (default: no lower boundary) - max_entries_to_bins_ratio: same but upper boundary instead of lower boundary (default: no upper boundary)","title":"&#10551; add_stat_mask"},{"location":"src/HistStruct/#add95highstat95mask","text":"full signature: def add_highstat_mask( self, name, histnames=None, entries_to_bins_ratio=100 ) comments: shorthand call to add_stat_mask with only lower boundary and no upper boundary for statistics input arguments: - entries_to_bins_ratio: number of entries divided by number of bins, lower boundary for statistics others: see add_stat_mask","title":"&#10551; add_highstat_mask"},{"location":"src/HistStruct/#pass95masks","text":"full signature: def pass_masks( self, masknames, runnbs=None, lsnbs=None ) comments: get a list of booleans of lumisections whether they pass a given set of masks input arguments: - masknames: list of mask names - runnbs: list of run numbers (default: all in histstruct) - lsnbs: list of lumisection numbers (equally long as runnbs) (default: al in histstruct)","title":"&#10551; pass_masks"},{"location":"src/HistStruct/#get95masknames","text":"full signature: def get_masknames( self ) comments: return a list of all mask names in the current HistStruct","title":"&#10551; get_masknames"},{"location":"src/HistStruct/#get95mask","text":"full signature: def get_mask( self, name ) comments: return a mask in the current HistStruct","title":"&#10551; get_mask"},{"location":"src/HistStruct/#get95combined95mask","text":"full signature: def get_combined_mask( self, names ) comments: get a combined (intersection) mask given multiple mask names mostly for internal use; externally you can use get_histograms( histname, <list of mask names>) directly","title":"&#10551; get_combined_mask"},{"location":"src/HistStruct/#get95union95mask","text":"full signature: def get_union_mask( self, names ) comments: get a combined (union) mask given multiple mask names mostly for internal use","title":"&#10551; get_union_mask"},{"location":"src/HistStruct/#get95runnbs","text":"full signature: def get_runnbs( self, masknames=None ) comments: get the array of run numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array)","title":"&#10551; get_runnbs"},{"location":"src/HistStruct/#get95runnbs95unique","text":"full signature: def get_runnbs_unique( self, masknames=None ) comments: get a list of unique run numbers","title":"&#10551; get_runnbs_unique"},{"location":"src/HistStruct/#get95lsnbs","text":"full signature: def get_lsnbs( self, masknames=None ) comments: get the array of lumisection numbers, optionally after masking input arguments: - masknames: list of names of masks (default: no masking, return full array)","title":"&#10551; get_lsnbs"},{"location":"src/HistStruct/#get95index","text":"full signature: def get_index( self, runnb, lsnb ) comments: get the index in the current HistStruct of a given run and lumisection number input arguments: - runnb and lsnb: run and lumisection number respectively","title":"&#10551; get_index"},{"location":"src/HistStruct/#get95scores","text":"full signature: def get_scores( self, modelname, histname=None, setnames=None, masknames=None ) comments: get the array of scores for a given model and for a given histogram type, optionally after masking input arguments: - modelname: name of the model for which to retrieve the scores - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores - setnames: list of names of the histogram sets (use None for standard set) - masknames: list of names of masks (default: no masking, return full array) notes: - do not use setnames and masknames simultaneously, this is not defined - if multiple masks are given, the intersection is taken; if multiple sets are given, the union is taken - the classifiers in the appropriate model must have been evaluated before calling this method!","title":"&#10551; get_scores"},{"location":"src/HistStruct/#get95scores95array","text":"full signature: def get_scores_array( self, modelname, setnames=None, masknames=None ) comments: similar to get_scores, but with different return type: np array of shape (nhistograms, nhistogramtypes)","title":"&#10551; get_scores_array"},{"location":"src/HistStruct/#get95extscores","text":"full signature: def get_extscores( self, extname, histname=None ) comments: get the array of scores for a given histogram type in a given extra set. DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of the extra set (see also add_exthistograms) - histname: name of the histogram type for which to retrieve the score. if None, return a dict matching histnames to arrays of scores notes: - this method takes the scores from the HistStruct.extscores attribute; make sure to have evaluated the classifiers before calling this method, else an exception will be thrown.","title":"&#10551; get_extscores"},{"location":"src/HistStruct/#get95extscores95array","text":"full signature: def get_extscores_array( self, extname ) comments: similar to get_extscores, but with different return type: np array of shape (nhistograms, nhistogramtypes) DEPRECATED, DO NOT USE ANYMORE","title":"&#10551; get_extscores_array"},{"location":"src/HistStruct/#get95scores95ls","text":"full signature: def get_scores_ls( self, modelname, runnb, lsnb, histnames=None ) comments: get the scores for a given run/lumisection number and for given histogram names input arguments: - modelname: name of the model for which to retrieve the score - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score)","title":"&#10551; get_scores_ls"},{"location":"src/HistStruct/#get95globalscores","text":"full signature: def get_globalscores( self, modelname, setnames=None, masknames=None ) comments: get the array of global scores, optionally after masking input arguments: - modelname: name of the model for which to retrieve the global score - setnames: list of names of the histogram sets (use None for standard set) - masknames: list of names of masks (default: no masking, return full array) notes: - do not use setnames and masknames simultaneously, this is not defined - if multiple masks are given, the intersection is taken; if multiple sets are given, the union is taken - the classifiers in the appropriate model must have been evaluated before calling this method!","title":"&#10551; get_globalscores"},{"location":"src/HistStruct/#get95globalscores95jsonformat","text":"full signature: def get_globalscores_jsonformat( self, modelname=None ) comments: make a json format listing all lumisections in this histstruct the output list has entries for global scores and masks input arguments: - modelname: name of the model for wich to retrieve the global score if None, all available models will be used","title":"&#10551; get_globalscores_jsonformat"},{"location":"src/HistStruct/#get95globalscore95ls","text":"full signature: def get_globalscore_ls( self, modelname, runnb, lsnb ) comments: get the global score for a given run/lumisection number input arguments: - modelname: name of the model for which to retrieve the global score - runnb: run number - lsnb: lumisection number - histnames: names of the histogram types for which to retrieve the score. returns: - a dict matching each name in histnames to a score (or None if no valid score)","title":"&#10551; get_globalscore_ls"},{"location":"src/HistStruct/#get95globalscores95mask","text":"full signature: def get_globalscores_mask( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the mask for global score between specified boundaries input arguments: - modelname: name of the model for which to consider the global scores - masknames: list of additional masks (on top of score boundaries) to consider - setnames: list of set names for which to retrieve the global scores - score_up and score_down are upper and lower thresholds if both are not None, the mask for global scores between the boundaries are returned if score_up is None, the mask for global score > score_down are returned if score_down is None, the mask for global score < score_up are returned","title":"&#10551; get_globalscores_mask"},{"location":"src/HistStruct/#get95globalscores95indices","text":"full signature: def get_globalscores_indices( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the indices with a global score between specified boundaries input arguments: see get_globalscore_mask","title":"&#10551; get_globalscores_indices"},{"location":"src/HistStruct/#get95globalscores95runsls","text":"full signature: def get_globalscores_runsls( self, modelname, masknames=None, setnames=None, score_up=None, score_down=None ) comments: get the run and lumisection numbers with a global score between specified boundaries input arguments: see get_globalscore_mask","title":"&#10551; get_globalscores_runsls"},{"location":"src/HistStruct/#get95extglobalscores","text":"full signature: def get_extglobalscores( self, extname ) comments: get the array of global scores for one of the extra histogram sets DEPRECATED, DO NOT USE ANYMORE input arguments: - extname: name of the extra histogram set notes: - this method takes the scores from the HistStruct.extglobalscores attribute; make sure to have set this attribute with add_extglobalscores, else an exception will be thrown.","title":"&#10551; get_extglobalscores"},{"location":"src/HistStruct/#get95histograms","text":"full signature: def get_histograms( self, histname=None, masknames=None, setnames=None ) comments: get the array of histograms for a given type, optionally after masking input arguments: - histname: name of the histogram type to retrieve if None, return a dict matching histnames to arrays of histograms - masknames: list of names of masks (default: no masking, return full array) - setnames: list of names of the sets of extra histograms (see also add_exthistograms) if multiple setnames are provided, the union/concatenation is returned","title":"&#10551; get_histograms"},{"location":"src/HistStruct/#get95histogramsandscores","text":"full signature: def get_histogramsandscores( self, modelname=None, setnames=None, masknames=None, nrandoms=-1, nfirst=-1 ) comments: combination of get_histograms, get_scores and get_globalscores with additional options - modelname: name of the model for which to retrieve the score if None, no scores will be retrieved (only histograms) - setnames: list of names of histogram sets (use None for default set) - masknames: list of names of masks - nrandoms: if > 0, number of random instances to draw - nfirst: if > 0, number of first instances to keep return type: dict with keys 'histograms', 'scores' and 'globalscores' note that the values of scores and globalscores may be None if not initialized","title":"&#10551; get_histogramsandscores"},{"location":"src/HistStruct/#add95model","text":"full signature: def add_model( self, modelname, model ) comments: add a model to the HistStruct input arguments: - modelname: a name for the model - model: an instance of ModelInterface class with histnames corresponding to the ones for this HistStruct","title":"&#10551; add_model"},{"location":"src/HistStruct/#check95model","text":"full signature: def check_model( self, modelname ) comments: check if a given model name is present in the HistStruct input arguments: - modelname: name of the model to check","title":"&#10551; check_model"},{"location":"src/HistStruct/#remove95model","text":"full signature: def remove_model( self, modelname ) comments: remove a model input arguments: - modelname: name of the model to remove","title":"&#10551; remove_model"},{"location":"src/HistStruct/#train95classifier","text":"full signature: def train_classifier( self, modelname, histname, masknames=None, setnames=None, **kwargs ) comments: train a histogram classifier input arguments: - modelname: name of the model for which to train the classifiers - histname: a valid histogram name present in the HistStruct for which to train the classifier - masknames: list of masks the classifiers should be trained on - setnames: list of names of sets of extra histograms on which the classifiers should be trained - kwargs: additional keyword arguments for training","title":"&#10551; train_classifier"},{"location":"src/HistStruct/#train95classifiers","text":"full signature: def train_classifiers( self, modelname, masknames=None, setnames=None, **kwargs ) comments: train histogram classifiers for all histogram types input arguments: - modelname: name of the model for which to train the classifiers - masknames: list of masks the classifiers should be trained on - setnames: list of names of sets of extra histograms on which the classifiers should be trained - kwargs: additional keyword arguments for training","title":"&#10551; train_classifiers"},{"location":"src/HistStruct/#evaluate95classifier","text":"full signature: def evaluate_classifier( self, modelname, histname, masknames=None, setnames=None ) comments: evaluate a histogram classifier input arguments: - modelname: name of the model for wich to evaluate the classifiers - histname: a valid histogram name present in the HistStruct for which to evaluate the classifier - masknames: list of masks if the classifiers should be evaluated on a subset only (e.g. for speed) - setnames: list of names of sets of extra histograms for which the classifiers should be evaluated","title":"&#10551; evaluate_classifier"},{"location":"src/HistStruct/#evaluate95classifiers","text":"full signature: def evaluate_classifiers( self, modelname, masknames=None, setnames=None ) comments: evaluate histogram classifiers for all histogram types input arguments: - modelname: name of the model for wich to evaluate the classifiers - masknames: list of masks if the classifiers should be evaluated on a subset only (e.g. for speed) - setnames: list of names of a set of extra histograms for which the classifiers should be evaluated","title":"&#10551; evaluate_classifiers"},{"location":"src/HistStruct/#set95fitter","text":"full signature: def set_fitter( self, modelname, fitter ) comments: set the fitter for a given model","title":"&#10551; set_fitter"},{"location":"src/HistStruct/#train95fitter","text":"full signature: def train_fitter( self, modelname, masknames=None, setnames=None, verbose=False, **kwargs ) comments: train the fitter for a given model input arguments: - modelname: name of the model to train - masknames: list of mask names for training set - setnames: list of set names for training set - kwargs: additional keyword arguments for fitting note: use either masksnames or setnames, not both!","title":"&#10551; train_fitter"},{"location":"src/HistStruct/#train95partial95fitters","text":"full signature: def train_partial_fitters( self, modelname, dimslist, masknames=None, setnames=None, **kwargs ) comments: train partial fitters for a given model input arguments: - modelname: name of the model to train - dimslist: list of tuples with integer dimension numbers - masknames: list of mask names for training set - setnames: list of set names for training set - kwargs: additional keyword arguments for fitting note: use either masksnames or setnames, not both! note: see also plot_partial_fit for a convenient plotting method!","title":"&#10551; train_partial_fitters"},{"location":"src/HistStruct/#evaluate95fitter","text":"full signature: def evaluate_fitter( self, modelname, masknames=None, setnames=None, verbose=False ) comments: evaluate the fitter for a given model input arguments: - modelname: name of the model for which to evaluate the fitter - masknames: list of mask names if the fitter should be evaluated on a subset only (e.g. for speed) - setnames: list of set names of extra histograms for which the fitter should be evaluated","title":"&#10551; evaluate_fitter"},{"location":"src/HistStruct/#evaluate95fitter95on95point","text":"full signature: def evaluate_fitter_on_point( self, modelname, point ) comments: evaluate the fitter on a given points input arguments: - modelname: name of the model for which to evaluate the fitter - points: dict matching histnames to scores (one float per histogram type) (e.g. as returned by get_scores_ls) returns: - the global score for the provided point (a float)","title":"&#10551; evaluate_fitter_on_point"},{"location":"src/HistStruct/#evaluate95fitter95on95points","text":"full signature: def evaluate_fitter_on_points( self, modelname, points ) comments: evaluate the fitter on a given set of points input arguments: - modelname: name of the model for which to evaluate the fitter - points: dict matching histnames to scores (np array of shape (nhistograms)) returns: - the global scores for the provided points","title":"&#10551; evaluate_fitter_on_points"},{"location":"src/HistStruct/#plot95histograms","text":"full signature: def plot_histograms( self, histnames=None, masknames=None, histograms=None, ncols=4, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a HistStruct, optionally after masking input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list of list of mask names note: each element in masknames represents a set of masks to apply; the histograms passing different sets of masks are plotted in different colors - histograms: list of dicts of histnames to 2D arrays of histograms, can be used to plot a given collection of histograms directly, and bypass the histnames and masknames arguments (note: for use in the gui, not recommended outside of it) - ncols: number of columns (only relevant for 1D histograms) - colorlist: list of matplotlib colors, must have same length as masknames - labellist: list of labels for the legend, must have same legnth as masknames - transparencylist: list of transparency values, must have same length as masknames - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets","title":"&#10551; plot_histograms"},{"location":"src/HistStruct/#plot95histograms951d","text":"full signature: def plot_histograms_1d( self, histnames=None, masknames=None, histograms=None, ncols=4, colorlist=[], labellist=[], transparencylist=[], titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms","title":"&#10551; plot_histograms_1d"},{"location":"src/HistStruct/#plot95histograms952d","text":"full signature: def plot_histograms_2d( self, histnames=None, masknames=None, histograms=None, labellist=[], titledict=None, xaxtitledict=None, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms","title":"&#10551; plot_histograms_2d"},{"location":"src/HistStruct/#plot95histograms95run","text":"full signature: def plot_histograms_run( self, histnames=None, masknames=None, histograms=None, ncols=4, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot a set of histograms in a HistStruct with a smooth color gradient. typical use case: plot a single run. note: only for 1D histograms! input arguments: - histnames: list of names of the histogram types to plot (default: all) - masknames: list mask names (typically should contain a run number mask) - histograms: dict of histnames to 2D arrays of histograms, can be used to plot a given collection of histograms directly, and bypass the histnames and masknames arguments (note: for use in the gui, not recommended outside of it. - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_hists_multi","title":"&#10551; plot_histograms_run"},{"location":"src/HistStruct/#plot95histograms95run951d","text":"full signature: def plot_histograms_run_1d( self, histnames=None, masknames=None, histograms=None, ncols=4, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs ) comments: plot the histograms in a histstruct, optionally after masking internal helper function, use only via plot_histograms_run","title":"&#10551; plot_histograms_run_1d"},{"location":"src/HistStruct/#plot95ls","text":"full signature: def plot_ls( self, runnb, lsnb, histnames=None, histlabel=None, ncols=4, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction input arguments: - runnb: run number - lsnb: lumisection number - histnames: names of histogram types to plot (default: all) - histlabel: legend entry for the histogram (default: run and lumisection number) - recohist: dict matching histogram names to reconstructed histograms notes: - 'reconstructed histograms' refers to e.g. autoencoder or NMF reconstructions; some models (e.g. simply looking at histogram moments) might not have this kind of reconstruction - in principle one histogram per key is expected, but still the the shape must be 2D (i.e. (1,nbins)) - in case recohist is set to a valid model name present in the current HistStruct, the reconstruction is calculated on the fly for the input histograms - recohistlabel: legend entry for the reco histograms - refhists: dict matching histogram names to reference histograms notes: - multiple histograms (i.e. a 2D array) per key are expected; in case there is only one reference histogram, it must be reshaped into (1,nbins) - refhistslabel: legend entry for the reference histograms - titledict: dict mapping histogram names to titles for the subplots (default: title = histogram name) - xaxtitledict: dict mapping histogram names to x-axis titles for the subplots (default: no x-axis title) - yaxtitledict: dict mapping histogram names to y-axis titles for the subplots (default: no y-axis title) - physicalxax: bool whether to use physical x-axis range or simply use bin number (default) - kwargs: keyword arguments passed down to plot_utils.plot_sets","title":"&#10551; plot_ls"},{"location":"src/HistStruct/#plot95run","text":"full signature: def plot_run( self, runnb, masknames=None, ncols=4, recohist=None, recohistlabel='reco', refhists=None, refhistslabel='reference', doprint=False) comments: call plot_ls for all lumisections in a given run","title":"&#10551; plot_run"},{"location":"src/HistStruct/#plot95ls951d","text":"full signature: def plot_ls_1d( self, runnb, lsnb, histnames=None, histlabel=None, ncols=4, recohist=None, recohistlabel='Reconstruction', refhists=None, refhistslabel='Reference histograms', refhiststransparency=None, titledict=None, xaxtitledict=None, physicalxax=False, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their references and/or their reconstruction internal helper function, use only via plot_ls","title":"&#10551; plot_ls_1d"},{"location":"src/HistStruct/#class-classifier-selfmodelsrecohistclassifiersname","text":"comments: (no valid documentation found)","title":"[class] classifier = self.models[recohist].classifiers[name]"},{"location":"src/HistStruct/#plot95ls952d","text":"full signature: def plot_ls_2d( self, runnb, lsnb, histnames=None, histlabel=None, recohist=None, recohistlabel='Reconstruction', titledict=None, xaxtitledict=None, yaxtitledict=None, **kwargs) comments: plot the histograms in a HistStruct for a given run/ls number versus their reconstruction internal helper function, use only via plot_ls","title":"&#10551; plot_ls_2d"},{"location":"src/HistStruct/#class-classifier-selfmodelsrecohistclassifiersname_1","text":"comments: (no valid documentation found)","title":"[class] classifier = self.models[recohist].classifiers[name]"},{"location":"src/HistStruct/#plot95ls95score","text":"full signature: def plot_ls_score( self, modelname, runnb, lsnb, ncols=4, masknames=None, setnames=None, **kwargs ) comments: plot the score of a given lumisection for each histogram type compared to reference scores input arguments: - modelname: name of the model for which to retrieve the score - runnb: run number - lsnb: lumisection number - masknames: list of mask names for the reference scores - setnames: list of set names for the reference scores - kwargs: additional keyword arguments passed down to pu.plot_score_dist","title":"&#10551; plot_ls_score"},{"location":"src/HistStruct/#plot95partial95fit","text":"full signature: def plot_partial_fit( self, modelname, dims, clusters, **kwargs) comments: plot a partial fit calculated with train_partial_fitters input arguments: - modelname: name of the model for which to plot the partial fits - dims: a tuple of length 1 or 2 with integer dimension indices note: the partial fit for this dimension must have been calculated with train_partial_fitters first - clusters: a list of the different point clusters to plot each element in the list should be a dict of the form {'masknames': [list of mask names]} or {'setnames': [list of set names]} - kwargs: plot options passed down to pu.plot_fit_1d_clusters or pu.plot_fit_2d_clusters; some of them have to have the same length as clusters (e.g. colors and labels)","title":"&#10551; plot_partial_fit"},{"location":"src/HistStruct/#plot95score95dist","text":"full signature: def plot_score_dist( self, modelname, histname=None, masknames_sig=None, setnames_sig=None, masknames_bkg=None, setnames_bkg=None, **kwargs ) comments: plot a 1D score distribution input arguments: - modelname: name of the model for which to retrieve the scores - histname: type of histogram for which to retrieve the scores if None, the global scores will be retrieved - masknames_sig, setnames_sig: lists of mask or set names for signal distribution - masknames_bkg, setnames_bkg: lists of mask or set names for background distribution note: in case of multiple masks, the intersection is taken (as usual); in case of multiple sets, the union is taken! - kwargs: additional keyword arguments passed down to pu.plot_score_dist","title":"&#10551; plot_score_dist"},{"location":"src/Model/","text":"Model Model: grouping classifiers for different histogram types This class represents a general model for assigning a score to a lumisection. It consists of two distinct parts: - a collection of classifiers acting on individual histogramgs (one for each type). - a fitter to assign a probability density to the output scores obtained in the previous step. The types of histograms, classifiers, and fitter can be freely chosen. This class does not contain the histograms or other data; it only contains the classifiers and fitter. Use the derived class ModelInterface to make the bridge between a HistStruct (holding the data) and a Model (holding the classifiers and fitter). [class] Model comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self, histnames ) comments: initializer input arguments: - histnames: list of the histogram names for this Model. this is the only argument needed for initialization, use the functions set_classifiers and set_fitter to set the classifiers and fitter respectively. \u2937 set_classifiers full signature: def set_classifiers( self, classifiers ) comments: set the classifiers for this Model input arguments: - classifiers: dict of histnames to classifiers. the histnames must match the ones used to initialize this Model, the classifiers must be a subtype of HistogramClassifier. [class] classifier = classifiers[histname] comments: (no valid documentation found) \u2937 set_fitter full signature: def set_fitter( self, fitter ) comments: set the fitter for this Model input arguments: - fitter: an (untrained) object of type CloudFitter \u2937 check_classifier full signature: def check_classifier( self, histname ) comments: check if a classifier was initialized input arguments: - histname: type of histogram for which to check the classifier \u2937 check_fitter full signature: def check_fitter( self ) comments: check if a fitter was initialized \u2937 train_classifier full signature: def train_classifier( self, histname, histograms, **kwargs ) comments: train a classifier input arguments: - histname: histogram name for which to train the classifier - histograms: the histograms for training, np array of shape (nhistograms,nbins) - kwargs: additional keyword arguments for training \u2937 train_classifiers full signature: def train_classifiers( self, histograms, **kwargs ) comments: train classifiers for all histograms in this Model input arguments: - histograms: the histograms for training, dict of histnames to np arrays of shape (nhistograms,nbins) - kwargs: additional keyword arguments for training \u2937 evaluate_classifier full signature: def evaluate_classifier( self, histname, histograms, mask=None ) comments: evaluate a classifier and return the score input arguments: - histname: histogram name for which to evaluate the classifier - histograms: the histograms for evaluation, np array of shape (nhistograms,nbins) - mask: a np boolean array masking the histograms to be evaluated returns: - a np array of shape (nhistograms) with the scores note: masked-out indices are set to np.nan! \u2937 evaluate_classifiers full signature: def evaluate_classifiers( self, histograms, mask=None ) comments: evaluate the classifiers and return the scores input arguments: - histograms: dict of histnames to histogram arrays (shape (nhistograms,nbins)) - mask: a np boolean array masking the histograms to be evaluated returns: - dict of histnames to scores (shape (nhistograms)) note: masked-out indices are set to np.nan! \u2937 get_point_array full signature: def get_point_array( self, points ) comments: for internal use in train_fitter and evaluate_fitter input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) \u2937 train_fitter full signature: def train_fitter( self, points, verbose=False, **kwargs ) comments: train the fitter input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - kwargs: additional keyword arguments for fitting \u2937 evaluate_fitter full signature: def evaluate_fitter( self, points, mask=None, verbose=False ) comments: evaluate the fitter and return the scores input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - mask: a np boolean array masking the histograms to be evaluated returns: - a np array of shape (nhistograms) with the scores note: masked-out indices are set to np.nan!","title":"Model"},{"location":"src/Model/#model","text":"Model: grouping classifiers for different histogram types This class represents a general model for assigning a score to a lumisection. It consists of two distinct parts: - a collection of classifiers acting on individual histogramgs (one for each type). - a fitter to assign a probability density to the output scores obtained in the previous step. The types of histograms, classifiers, and fitter can be freely chosen. This class does not contain the histograms or other data; it only contains the classifiers and fitter. Use the derived class ModelInterface to make the bridge between a HistStruct (holding the data) and a Model (holding the classifiers and fitter).","title":"Model"},{"location":"src/Model/#class-model","text":"comments: (no valid documentation found)","title":"[class] Model"},{"location":"src/Model/#9595init9595","text":"full signature: def __init__( self, histnames ) comments: initializer input arguments: - histnames: list of the histogram names for this Model. this is the only argument needed for initialization, use the functions set_classifiers and set_fitter to set the classifiers and fitter respectively.","title":"&#10551; __init__"},{"location":"src/Model/#set95classifiers","text":"full signature: def set_classifiers( self, classifiers ) comments: set the classifiers for this Model input arguments: - classifiers: dict of histnames to classifiers. the histnames must match the ones used to initialize this Model, the classifiers must be a subtype of HistogramClassifier.","title":"&#10551; set_classifiers"},{"location":"src/Model/#class-classifier-classifiershistname","text":"comments: (no valid documentation found)","title":"[class] classifier = classifiers[histname]"},{"location":"src/Model/#set95fitter","text":"full signature: def set_fitter( self, fitter ) comments: set the fitter for this Model input arguments: - fitter: an (untrained) object of type CloudFitter","title":"&#10551; set_fitter"},{"location":"src/Model/#check95classifier","text":"full signature: def check_classifier( self, histname ) comments: check if a classifier was initialized input arguments: - histname: type of histogram for which to check the classifier","title":"&#10551; check_classifier"},{"location":"src/Model/#check95fitter","text":"full signature: def check_fitter( self ) comments: check if a fitter was initialized","title":"&#10551; check_fitter"},{"location":"src/Model/#train95classifier","text":"full signature: def train_classifier( self, histname, histograms, **kwargs ) comments: train a classifier input arguments: - histname: histogram name for which to train the classifier - histograms: the histograms for training, np array of shape (nhistograms,nbins) - kwargs: additional keyword arguments for training","title":"&#10551; train_classifier"},{"location":"src/Model/#train95classifiers","text":"full signature: def train_classifiers( self, histograms, **kwargs ) comments: train classifiers for all histograms in this Model input arguments: - histograms: the histograms for training, dict of histnames to np arrays of shape (nhistograms,nbins) - kwargs: additional keyword arguments for training","title":"&#10551; train_classifiers"},{"location":"src/Model/#evaluate95classifier","text":"full signature: def evaluate_classifier( self, histname, histograms, mask=None ) comments: evaluate a classifier and return the score input arguments: - histname: histogram name for which to evaluate the classifier - histograms: the histograms for evaluation, np array of shape (nhistograms,nbins) - mask: a np boolean array masking the histograms to be evaluated returns: - a np array of shape (nhistograms) with the scores note: masked-out indices are set to np.nan!","title":"&#10551; evaluate_classifier"},{"location":"src/Model/#evaluate95classifiers","text":"full signature: def evaluate_classifiers( self, histograms, mask=None ) comments: evaluate the classifiers and return the scores input arguments: - histograms: dict of histnames to histogram arrays (shape (nhistograms,nbins)) - mask: a np boolean array masking the histograms to be evaluated returns: - dict of histnames to scores (shape (nhistograms)) note: masked-out indices are set to np.nan!","title":"&#10551; evaluate_classifiers"},{"location":"src/Model/#get95point95array","text":"full signature: def get_point_array( self, points ) comments: for internal use in train_fitter and evaluate_fitter input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms))","title":"&#10551; get_point_array"},{"location":"src/Model/#train95fitter","text":"full signature: def train_fitter( self, points, verbose=False, **kwargs ) comments: train the fitter input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - kwargs: additional keyword arguments for fitting","title":"&#10551; train_fitter"},{"location":"src/Model/#evaluate95fitter","text":"full signature: def evaluate_fitter( self, points, mask=None, verbose=False ) comments: evaluate the fitter and return the scores input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - mask: a np boolean array masking the histograms to be evaluated returns: - a np array of shape (nhistograms) with the scores note: masked-out indices are set to np.nan!","title":"&#10551; evaluate_fitter"},{"location":"src/ModelInterface/","text":"ModelInterface ModelInterface: extension of Model class interfaced by HistStruct This class is the interface between a Model (holding classifiers and fitters) and a HistStruct (holding histogram data). It stores the classifier and model scores for the histograms in a HistStruct. [class] ModelInterface comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self, histnames ) comments: initializer input arguments: - histnames: list of the histogram names for this Model(Interface). \u2937 __str__ full signature: def __str__( self ) comments: get a printable representation of a ModelInterface \u2937 add_setname full signature: def add_setname( self, setname ) comments: initialize empty scores for extended set input arguments: - setname: name of extended set \u2937 check_setname full signature: def check_setname( self, setname ) comments: check if a setname is present input arguments: - setname: name of the set to check \u2937 check_setnames full signature: def check_setnames( self, setnames ) comments: check if all names in a list of set names are present \u2937 check_scores full signature: def check_scores( self, histnames=None, setnames=None ) comments: check if scores are present for a given set name input arguments: - histnames: list of histogram names for which to check the scores (default: all) - setname: list of set names for which to check the scores (default: standard set) \u2937 check_globalscores full signature: def check_globalscores( self, setnames=None ) comments: check if global scores are present for a given set name input arguments: - setname: list of set names for which to check the scores (default: standard set) \u2937 evaluate_store_classifier full signature: def evaluate_store_classifier( self, histname, histograms, mask=None, setname=None ) comments: same as Model.evaluate_classifier but store the result internally input arguments: - histname: histogram name for which to evaluate the classifier - histograms: the histograms for evaluation, np array of shape (nhistograms,nbins) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set) \u2937 evaluate_store_classifiers full signature: def evaluate_store_classifiers( self, histograms, mask=None, setname=None ) comments: same as Model.evaluate_classifiers but store the result internally input arguments: - histograms: dict of histnames to histogram arrays (shape (nhistograms,nbins)) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set) \u2937 evaluate_store_fitter full signature: def evaluate_store_fitter( self, points, mask=None, setname=None, verbose=False ) comments: same as Model.evaluate_fitter but store the result internally input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set) \u2937 get_scores full signature: def get_scores( self, setnames=None, histname=None ) comments: get the scores stored internally input arguments: - setnames: list of names of extended sets (default: standard set) - histname: name of histogram type for which to get the scores if specified, an array of scores is returned. if not, a dict matching histnames to arrays of scores is returned. \u2937 get_globalscores full signature: def get_globalscores( self, setnames=None ) comments: get the global scores stored internally input arguments: - setnames: list of name of extended sets (default: standard set) \u2937 get_globalscores_mask full signature: def get_globalscores_mask( self, setnames=None, score_up=None, score_down=None ) comments: get a mask of global scores within boundaries input arguments: - setnames: list of name of extended sets (default: standard set) - score_up and score_down are upper and lower thresholds if both are not None, the mask for global scores between the boundaries are returned if score_up is None, the mask for global score > score_down are returned if score_down is None, the mask for global score < score_up are returned \u2937 get_globalscores_indices full signature: def get_globalscores_indices( self, setnames=None, score_up=None, score_down=None ) comments: get the indices of global scores within boundaries input arguments: - setnames: list of name of extended sets (default: standard set) - score_up and score_down are upper and lower thresholds if both are not None, the indices with global scores between the boundaries are returned if score_up is None, the indices with global score > score_down are returned if score_down is None, the indices with global score < score_up are returned \u2937 train_partial_fitters full signature: def train_partial_fitters( self, dimslist, points, **kwargs ) comments: train partial fitters on a given set of dimensions input arguments: - dimslist: list of tuples with integer dimension numbers - points: dict matching histnames to scores (np array of shape (nhistograms)) - kwargs: additional keyword arguments for fitting \u2937 save full signature: def save( self, path, save_classifiers=True, save_fitter=True ) comments: save a ModelInterface object to a pkl file input arguments: - path where to store the file - save_classifiers: a boolean whether to include the classifiers (alternative: only scores) - save_fitter: a boolean whether to include the fitter (alternative: only scores) [class] classifiers = dict comments: (no valid documentation found) [class] classifier.save comments: get all files to store in the zip file \u2937 load full signature: def load( self, path, load_classifiers=True, load_fitter=True, verbose=False ) comments: load a ModelInterface object input arguments: - path to a zip file containing a ModelInterface object - load_classifiers: a boolean whether to load the classifiers if present - load_fitter: a boolean whether to load the fitter if present - verbose: boolean whether to print some information","title":"ModelInterface"},{"location":"src/ModelInterface/#modelinterface","text":"ModelInterface: extension of Model class interfaced by HistStruct This class is the interface between a Model (holding classifiers and fitters) and a HistStruct (holding histogram data). It stores the classifier and model scores for the histograms in a HistStruct.","title":"ModelInterface"},{"location":"src/ModelInterface/#class-modelinterface","text":"comments: (no valid documentation found)","title":"[class] ModelInterface"},{"location":"src/ModelInterface/#9595init9595","text":"full signature: def __init__( self, histnames ) comments: initializer input arguments: - histnames: list of the histogram names for this Model(Interface).","title":"&#10551; __init__"},{"location":"src/ModelInterface/#9595str9595","text":"full signature: def __str__( self ) comments: get a printable representation of a ModelInterface","title":"&#10551; __str__"},{"location":"src/ModelInterface/#add95setname","text":"full signature: def add_setname( self, setname ) comments: initialize empty scores for extended set input arguments: - setname: name of extended set","title":"&#10551; add_setname"},{"location":"src/ModelInterface/#check95setname","text":"full signature: def check_setname( self, setname ) comments: check if a setname is present input arguments: - setname: name of the set to check","title":"&#10551; check_setname"},{"location":"src/ModelInterface/#check95setnames","text":"full signature: def check_setnames( self, setnames ) comments: check if all names in a list of set names are present","title":"&#10551; check_setnames"},{"location":"src/ModelInterface/#check95scores","text":"full signature: def check_scores( self, histnames=None, setnames=None ) comments: check if scores are present for a given set name input arguments: - histnames: list of histogram names for which to check the scores (default: all) - setname: list of set names for which to check the scores (default: standard set)","title":"&#10551; check_scores"},{"location":"src/ModelInterface/#check95globalscores","text":"full signature: def check_globalscores( self, setnames=None ) comments: check if global scores are present for a given set name input arguments: - setname: list of set names for which to check the scores (default: standard set)","title":"&#10551; check_globalscores"},{"location":"src/ModelInterface/#evaluate95store95classifier","text":"full signature: def evaluate_store_classifier( self, histname, histograms, mask=None, setname=None ) comments: same as Model.evaluate_classifier but store the result internally input arguments: - histname: histogram name for which to evaluate the classifier - histograms: the histograms for evaluation, np array of shape (nhistograms,nbins) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set)","title":"&#10551; evaluate_store_classifier"},{"location":"src/ModelInterface/#evaluate95store95classifiers","text":"full signature: def evaluate_store_classifiers( self, histograms, mask=None, setname=None ) comments: same as Model.evaluate_classifiers but store the result internally input arguments: - histograms: dict of histnames to histogram arrays (shape (nhistograms,nbins)) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set)","title":"&#10551; evaluate_store_classifiers"},{"location":"src/ModelInterface/#evaluate95store95fitter","text":"full signature: def evaluate_store_fitter( self, points, mask=None, setname=None, verbose=False ) comments: same as Model.evaluate_fitter but store the result internally input arguments: - points: dict matching histnames to scores (np array of shape (nhistograms)) - mask: a np boolean array masking the histograms to be evaluated - setname: name of extended set (default: standard set)","title":"&#10551; evaluate_store_fitter"},{"location":"src/ModelInterface/#get95scores","text":"full signature: def get_scores( self, setnames=None, histname=None ) comments: get the scores stored internally input arguments: - setnames: list of names of extended sets (default: standard set) - histname: name of histogram type for which to get the scores if specified, an array of scores is returned. if not, a dict matching histnames to arrays of scores is returned.","title":"&#10551; get_scores"},{"location":"src/ModelInterface/#get95globalscores","text":"full signature: def get_globalscores( self, setnames=None ) comments: get the global scores stored internally input arguments: - setnames: list of name of extended sets (default: standard set)","title":"&#10551; get_globalscores"},{"location":"src/ModelInterface/#get95globalscores95mask","text":"full signature: def get_globalscores_mask( self, setnames=None, score_up=None, score_down=None ) comments: get a mask of global scores within boundaries input arguments: - setnames: list of name of extended sets (default: standard set) - score_up and score_down are upper and lower thresholds if both are not None, the mask for global scores between the boundaries are returned if score_up is None, the mask for global score > score_down are returned if score_down is None, the mask for global score < score_up are returned","title":"&#10551; get_globalscores_mask"},{"location":"src/ModelInterface/#get95globalscores95indices","text":"full signature: def get_globalscores_indices( self, setnames=None, score_up=None, score_down=None ) comments: get the indices of global scores within boundaries input arguments: - setnames: list of name of extended sets (default: standard set) - score_up and score_down are upper and lower thresholds if both are not None, the indices with global scores between the boundaries are returned if score_up is None, the indices with global score > score_down are returned if score_down is None, the indices with global score < score_up are returned","title":"&#10551; get_globalscores_indices"},{"location":"src/ModelInterface/#train95partial95fitters","text":"full signature: def train_partial_fitters( self, dimslist, points, **kwargs ) comments: train partial fitters on a given set of dimensions input arguments: - dimslist: list of tuples with integer dimension numbers - points: dict matching histnames to scores (np array of shape (nhistograms)) - kwargs: additional keyword arguments for fitting","title":"&#10551; train_partial_fitters"},{"location":"src/ModelInterface/#save","text":"full signature: def save( self, path, save_classifiers=True, save_fitter=True ) comments: save a ModelInterface object to a pkl file input arguments: - path where to store the file - save_classifiers: a boolean whether to include the classifiers (alternative: only scores) - save_fitter: a boolean whether to include the fitter (alternative: only scores)","title":"&#10551; save"},{"location":"src/ModelInterface/#class-classifiers-dict","text":"comments: (no valid documentation found)","title":"[class] classifiers = dict"},{"location":"src/ModelInterface/#class-classifiersave","text":"comments: get all files to store in the zip file","title":"[class] classifier.save"},{"location":"src/ModelInterface/#load","text":"full signature: def load( self, path, load_classifiers=True, load_fitter=True, verbose=False ) comments: load a ModelInterface object input arguments: - path to a zip file containing a ModelInterface object - load_classifiers: a boolean whether to load the classifiers if present - load_fitter: a boolean whether to load the fitter if present - verbose: boolean whether to print some information","title":"&#10551; load"},{"location":"src/PlotStyleParser/","text":"PlotStyleParser [class] PlotStyleParser comments: (no valid documentation found) \u2937 __init__ full signature: def __init__(self, jsonfile=None) comments: (no valid documentation found) \u2937 load full signature: def load(self, jsonfile) comments: (no valid documentation found) \u2937 get_general_plot_options full signature: def get_general_plot_options(self) comments: (no valid documentation found) \u2937 get_general_plot_option full signature: def get_general_plot_option(self, attribute, histname=None) comments: (no valid documentation found) \u2937 get_title full signature: def get_title(self, histname=None) comments: (no valid documentation found) \u2937 get_titlesize full signature: def get_titlesize(self) comments: (no valid documentation found) \u2937 get_xaxtitle full signature: def get_xaxtitle(self, histname=None) comments: (no valid documentation found) \u2937 get_xaxtitlesize full signature: def get_xaxtitlesize(self) comments: (no valid documentation found) \u2937 get_physicalxax full signature: def get_physicalxax(self) comments: (no valid documentation found) \u2937 get_yaxtitle full signature: def get_yaxtitle(self, histname=None) comments: (no valid documentation found) \u2937 get_yaxtitlesize full signature: def get_yaxtitlesize(self) comments: (no valid documentation found) \u2937 get_ymaxfactor full signature: def get_ymaxfactor(self) comments: (no valid documentation found) \u2937 get_extratext full signature: def get_extratext(self, histname=None) comments: (no valid documentation found) \u2937 get_extratextsize full signature: def get_extratextsize(self) comments: (no valid documentation found) \u2937 get_legendsize full signature: def get_legendsize(self) comments: (no valid documentation found) \u2937 get_extracmstext full signature: def get_extracmstext(self) comments: (no valid documentation found) \u2937 get_cmstextsize full signature: def get_cmstextsize(self) comments: (no valid documentation found) \u2937 get_condtext full signature: def get_condtext(self) comments: (no valid documentation found) \u2937 get_condtextsize full signature: def get_condtextsize(self) comments: (no valid documentation found)","title":"PlotStyleParser"},{"location":"src/PlotStyleParser/#plotstyleparser","text":"","title":"PlotStyleParser"},{"location":"src/PlotStyleParser/#class-plotstyleparser","text":"comments: (no valid documentation found)","title":"[class] PlotStyleParser"},{"location":"src/PlotStyleParser/#9595init9595","text":"full signature: def __init__(self, jsonfile=None) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"src/PlotStyleParser/#load","text":"full signature: def load(self, jsonfile) comments: (no valid documentation found)","title":"&#10551; load"},{"location":"src/PlotStyleParser/#get95general95plot95options","text":"full signature: def get_general_plot_options(self) comments: (no valid documentation found)","title":"&#10551; get_general_plot_options"},{"location":"src/PlotStyleParser/#get95general95plot95option","text":"full signature: def get_general_plot_option(self, attribute, histname=None) comments: (no valid documentation found)","title":"&#10551; get_general_plot_option"},{"location":"src/PlotStyleParser/#get95title","text":"full signature: def get_title(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_title"},{"location":"src/PlotStyleParser/#get95titlesize","text":"full signature: def get_titlesize(self) comments: (no valid documentation found)","title":"&#10551; get_titlesize"},{"location":"src/PlotStyleParser/#get95xaxtitle","text":"full signature: def get_xaxtitle(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_xaxtitle"},{"location":"src/PlotStyleParser/#get95xaxtitlesize","text":"full signature: def get_xaxtitlesize(self) comments: (no valid documentation found)","title":"&#10551; get_xaxtitlesize"},{"location":"src/PlotStyleParser/#get95physicalxax","text":"full signature: def get_physicalxax(self) comments: (no valid documentation found)","title":"&#10551; get_physicalxax"},{"location":"src/PlotStyleParser/#get95yaxtitle","text":"full signature: def get_yaxtitle(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_yaxtitle"},{"location":"src/PlotStyleParser/#get95yaxtitlesize","text":"full signature: def get_yaxtitlesize(self) comments: (no valid documentation found)","title":"&#10551; get_yaxtitlesize"},{"location":"src/PlotStyleParser/#get95ymaxfactor","text":"full signature: def get_ymaxfactor(self) comments: (no valid documentation found)","title":"&#10551; get_ymaxfactor"},{"location":"src/PlotStyleParser/#get95extratext","text":"full signature: def get_extratext(self, histname=None) comments: (no valid documentation found)","title":"&#10551; get_extratext"},{"location":"src/PlotStyleParser/#get95extratextsize","text":"full signature: def get_extratextsize(self) comments: (no valid documentation found)","title":"&#10551; get_extratextsize"},{"location":"src/PlotStyleParser/#get95legendsize","text":"full signature: def get_legendsize(self) comments: (no valid documentation found)","title":"&#10551; get_legendsize"},{"location":"src/PlotStyleParser/#get95extracmstext","text":"full signature: def get_extracmstext(self) comments: (no valid documentation found)","title":"&#10551; get_extracmstext"},{"location":"src/PlotStyleParser/#get95cmstextsize","text":"full signature: def get_cmstextsize(self) comments: (no valid documentation found)","title":"&#10551; get_cmstextsize"},{"location":"src/PlotStyleParser/#get95condtext","text":"full signature: def get_condtext(self) comments: (no valid documentation found)","title":"&#10551; get_condtext"},{"location":"src/PlotStyleParser/#get95condtextsize","text":"full signature: def get_condtextsize(self) comments: (no valid documentation found)","title":"&#10551; get_condtextsize"},{"location":"src/classifiers/AutoEncoder/","text":"AutoEncoder Histogram classfier based on the MSE of an autoencoder reconstruction The AutoEncoder derives from the generic HistogramClassifier. For this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. In essence, it is just a wrapper for a tensorflow model. [class] AutoEncoder comments: histogram classfier based on the MSE of an autoencoder reconstruction the AutoEncoder derives from the generic HistogramClassifier. for this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. in essence, it is just a wrapper for a tensorflow model. \u2937 __init__ full signature: def __init__( self, model=None, modelpath=None ) comments: intializer from a tensorflow model input arguments: - model: a valid tensorflow model; it does not have to be trained already, the AutoEncoder.train function will take care of this. - modelpath: path to a stored tensorflow model, it does not have to be trained already, the AutoEncoder.train function will take care of this. note: model and modelpath are alternative options, they should not both be used simultaneously. \u2937 train full signature: def train( self, histograms, doplot=True, epochs=10, batch_size=500, shuffle=False, verbose=1, validation_split=0.1, **kwargs ) comments: train the model on a given set of input histograms input arguments: - histograms: set of training histograms, a numpy array of shape (nhistograms,nbins) - doplot: boolean whether to make a plot of the loss value - others: see the keras fit function - kwargs: additional arguments passed down to keras fit function \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their autoencoder reconstruction \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the autoencoder reconstruction of a set of histograms \u2937 save full signature: def save( self, path ) comments: save the underlying tensorflow model to a tensorflow SavedModel or H5 format. note: depending on the extension specified in path, the SavedModel or H5 format is chosen, see https://www.tensorflow.org/guide/keras/save_and_serialize \u2937 load full signature: def load( self, path, **kwargs ) comments: get an AutoEncoder instance from a saved tensorflow SavedModel or H5 file [class] classifier = AutoEncoder comments: (no valid documentation found)","title":"AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#autoencoder","text":"Histogram classfier based on the MSE of an autoencoder reconstruction The AutoEncoder derives from the generic HistogramClassifier. For this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. In essence, it is just a wrapper for a tensorflow model.","title":"AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#class-autoencoder","text":"comments: histogram classfier based on the MSE of an autoencoder reconstruction the AutoEncoder derives from the generic HistogramClassifier. for this specific classifier, the output score of a histogram is the mean-square-error (MSE) between the original histogram and its autoencoder reconstruction. in essence, it is just a wrapper for a tensorflow model.","title":"[class] AutoEncoder"},{"location":"src/classifiers/AutoEncoder/#9595init9595","text":"full signature: def __init__( self, model=None, modelpath=None ) comments: intializer from a tensorflow model input arguments: - model: a valid tensorflow model; it does not have to be trained already, the AutoEncoder.train function will take care of this. - modelpath: path to a stored tensorflow model, it does not have to be trained already, the AutoEncoder.train function will take care of this. note: model and modelpath are alternative options, they should not both be used simultaneously.","title":"&#10551; __init__"},{"location":"src/classifiers/AutoEncoder/#train","text":"full signature: def train( self, histograms, doplot=True, epochs=10, batch_size=500, shuffle=False, verbose=1, validation_split=0.1, **kwargs ) comments: train the model on a given set of input histograms input arguments: - histograms: set of training histograms, a numpy array of shape (nhistograms,nbins) - doplot: boolean whether to make a plot of the loss value - others: see the keras fit function - kwargs: additional arguments passed down to keras fit function","title":"&#10551; train"},{"location":"src/classifiers/AutoEncoder/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their autoencoder reconstruction","title":"&#10551; evaluate"},{"location":"src/classifiers/AutoEncoder/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the autoencoder reconstruction of a set of histograms","title":"&#10551; reconstruct"},{"location":"src/classifiers/AutoEncoder/#save","text":"full signature: def save( self, path ) comments: save the underlying tensorflow model to a tensorflow SavedModel or H5 format. note: depending on the extension specified in path, the SavedModel or H5 format is chosen, see https://www.tensorflow.org/guide/keras/save_and_serialize","title":"&#10551; save"},{"location":"src/classifiers/AutoEncoder/#load","text":"full signature: def load( self, path, **kwargs ) comments: get an AutoEncoder instance from a saved tensorflow SavedModel or H5 file","title":"&#10551; load"},{"location":"src/classifiers/AutoEncoder/#class-classifier-autoencoder","text":"comments: (no valid documentation found)","title":"[class] classifier = AutoEncoder"},{"location":"src/classifiers/HistogramClassifier/","text":"HistogramClassifier Abstract base class for histogram classifying objects Note that all concrete histogram classifiers must inherit from HistogramClassifier! A HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. How to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples! [class] HistogramClassifier comments: abstract base class for histogram classifying objects note that all concrete histogram classifiers must inherit from HistogramClassifier! a HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. how to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples! \u2937 __init__ full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class! \u2937 train full signature: def train( self, histograms ) comments: train the classifier on a set of input histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be none. \u2937 evaluate full signature: def evaluate( self, histograms ) comments: main function used to evaluate a set of histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be a 1D numpy array of shape (nhists), one number per histogram. \u2937 save full signature: def save( self, path ) comments: save a classifier to disk specific implementation in concrete classes, here only path creation \u2937 load full signature: def load( self, path ) comments: load a classifier object from disk specific implementation in concrete classes, here only path checking","title":"HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#histogramclassifier","text":"Abstract base class for histogram classifying objects Note that all concrete histogram classifiers must inherit from HistogramClassifier! A HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. How to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples!","title":"HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#class-histogramclassifier","text":"comments: abstract base class for histogram classifying objects note that all concrete histogram classifiers must inherit from HistogramClassifier! a HistogramClassifier can be any object that classifies a histogram; in more detail: - the input is a collection of histograms (of the same type), represented by a numpy array of shape (nhists,nbins) for 1D histograms or (nhists,nybins,nxbins) for 2D histograms. - the output is an array of numbers of shape (nhists). - the processing between input and output can in principle be anything, but usually some sort of discriminating power is assumed. how to make a concrete HistogramClassifier class: - define a class that inherits from HistogramClassifier - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples!","title":"[class] HistogramClassifier"},{"location":"src/classifiers/HistogramClassifier/#9595init9595","text":"full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class!","title":"&#10551; __init__"},{"location":"src/classifiers/HistogramClassifier/#train","text":"full signature: def train( self, histograms ) comments: train the classifier on a set of input histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be none.","title":"&#10551; train"},{"location":"src/classifiers/HistogramClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: main function used to evaluate a set of histograms this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins). output: expected to be a 1D numpy array of shape (nhists), one number per histogram.","title":"&#10551; evaluate"},{"location":"src/classifiers/HistogramClassifier/#save","text":"full signature: def save( self, path ) comments: save a classifier to disk specific implementation in concrete classes, here only path creation","title":"&#10551; save"},{"location":"src/classifiers/HistogramClassifier/#load","text":"full signature: def load( self, path ) comments: load a classifier object from disk specific implementation in concrete classes, here only path checking","title":"&#10551; load"},{"location":"src/classifiers/LandauClassifier/","text":"LandauClassifier landaufun full signature: def landaufun(x, landaumax, landauwidth, norm) comments: see https://en.wikipedia.org/wiki/Landau_distribution langaufun full signature: def langaufun(x, landaumax, landauwidth, norm, gausswidth) comments: (no valid documentation found) [class] LandauClassifier comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self, dogauss=False ) comments: (no valid documentation found) \u2937 train full signature: def train( self ) comments: (no valid documentation found) \u2937 fit full signature: def fit( self, histogram ) comments: find initial guess for the parameters \u2937 evaluate full signature: def evaluate( self, histograms ) comments: (no valid documentation found) \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: (no valid documentation found) \u2937 save full signature: def save( self, path ) comments: save the classifier \u2937 load full signature: def load( self, path, **kwargs ) comments: get a LandauClassifier instance from a pkl file","title":"LandauClassifier"},{"location":"src/classifiers/LandauClassifier/#landauclassifier","text":"","title":"LandauClassifier"},{"location":"src/classifiers/LandauClassifier/#landaufun","text":"full signature: def landaufun(x, landaumax, landauwidth, norm) comments: see https://en.wikipedia.org/wiki/Landau_distribution","title":"landaufun"},{"location":"src/classifiers/LandauClassifier/#langaufun","text":"full signature: def langaufun(x, landaumax, landauwidth, norm, gausswidth) comments: (no valid documentation found)","title":"langaufun"},{"location":"src/classifiers/LandauClassifier/#class-landauclassifier","text":"comments: (no valid documentation found)","title":"[class] LandauClassifier"},{"location":"src/classifiers/LandauClassifier/#9595init9595","text":"full signature: def __init__( self, dogauss=False ) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"src/classifiers/LandauClassifier/#train","text":"full signature: def train( self ) comments: (no valid documentation found)","title":"&#10551; train"},{"location":"src/classifiers/LandauClassifier/#fit","text":"full signature: def fit( self, histogram ) comments: find initial guess for the parameters","title":"&#10551; fit"},{"location":"src/classifiers/LandauClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: (no valid documentation found)","title":"&#10551; evaluate"},{"location":"src/classifiers/LandauClassifier/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: (no valid documentation found)","title":"&#10551; reconstruct"},{"location":"src/classifiers/LandauClassifier/#save","text":"full signature: def save( self, path ) comments: save the classifier","title":"&#10551; save"},{"location":"src/classifiers/LandauClassifier/#load","text":"full signature: def load( self, path, **kwargs ) comments: get a LandauClassifier instance from a pkl file","title":"&#10551; load"},{"location":"src/classifiers/MaxPullClassifier/","text":"MaxPullClassifier Histogram classification based on maximum pull between test histogram and reference histogram. Specifically intended for 2D histograms, but should in principle work for 1D as well. Ssee static function 'pull' for definition of bin-per-bin pull and other notes. pull full signature: def pull( testhist, refhist ) comments: calculate bin-per-bin pull between two histograms bin-per-bin pull is defined here preliminarily as (testhist(bin)-refhist(bin))/sqrt(refhist(bin)) notes: - bins in the denominator where refhist is < 1 are set to one! This is for histograms with absolute counts, and they should not be normalized! - instead another normalization is applied: the test histogram is multiplied by sum(refhist)/sum(testhist) before computing the pulls input arguments: - testhist, refhist: numpy arrays of the same shape output: numpy array of same shape as testhist and refhist maxabspull full signature: def maxabspull( testhist, refhist, n=1 ) comments: calculate maximum of bin-per-bin pulls (in absolute value) between two histograms see definition of bin-per-bin pull in function pull (above) input arguments: - testhist, refhist: numpy arrays of the same shape - n: nubmer of largest pull values to average over (default: 1, just take single maximum) output: a float [class] MaxPullClassifier comments: histogram classification based on maximum pull between test histogram and reference histogram. specifically intended for 2D histograms, but should in principle work for 1D as well. see static function pull (above) for definition of bin-per-bin pull and other notes. \u2937 __init__ full signature: def __init__( self, nmaxpulls=1 ) comments: initializer input arguments: - nmaxpulls: number of largest pull values to average over (default: 1, just take single maximum) \u2937 set_nmaxpulls full signature: def set_nmaxpulls( self, nmaxpulls ) comments: set the nmaxpulls parameter (see also initializer) \u2937 train full signature: def train( self, refhist ) comments: 'train' the classifier, i.e. set the reference histogram. input arguments: - refhist: a numpy array of shape (1,nbins) or (1,nybins,nxbins) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the histograms based on their max bin-per-bin pull (in absolute value) with respect to a reference histogram \u2937 getpull full signature: def getpull( self, histogram ) comments: get the pull histogram for a given test histogram input arguments: histogram: a single histogram, i.e. numpy array of shape (nbins) for 1D or (nybins,nxbins) for 2D. output: numpy array of same shape as histogram containing bin-per-bin pull w.r.t. reference histogram","title":"MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#maxpullclassifier","text":"Histogram classification based on maximum pull between test histogram and reference histogram. Specifically intended for 2D histograms, but should in principle work for 1D as well. Ssee static function 'pull' for definition of bin-per-bin pull and other notes.","title":"MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#pull","text":"full signature: def pull( testhist, refhist ) comments: calculate bin-per-bin pull between two histograms bin-per-bin pull is defined here preliminarily as (testhist(bin)-refhist(bin))/sqrt(refhist(bin)) notes: - bins in the denominator where refhist is < 1 are set to one! This is for histograms with absolute counts, and they should not be normalized! - instead another normalization is applied: the test histogram is multiplied by sum(refhist)/sum(testhist) before computing the pulls input arguments: - testhist, refhist: numpy arrays of the same shape output: numpy array of same shape as testhist and refhist","title":"pull"},{"location":"src/classifiers/MaxPullClassifier/#maxabspull","text":"full signature: def maxabspull( testhist, refhist, n=1 ) comments: calculate maximum of bin-per-bin pulls (in absolute value) between two histograms see definition of bin-per-bin pull in function pull (above) input arguments: - testhist, refhist: numpy arrays of the same shape - n: nubmer of largest pull values to average over (default: 1, just take single maximum) output: a float","title":"maxabspull"},{"location":"src/classifiers/MaxPullClassifier/#class-maxpullclassifier","text":"comments: histogram classification based on maximum pull between test histogram and reference histogram. specifically intended for 2D histograms, but should in principle work for 1D as well. see static function pull (above) for definition of bin-per-bin pull and other notes.","title":"[class] MaxPullClassifier"},{"location":"src/classifiers/MaxPullClassifier/#9595init9595","text":"full signature: def __init__( self, nmaxpulls=1 ) comments: initializer input arguments: - nmaxpulls: number of largest pull values to average over (default: 1, just take single maximum)","title":"&#10551; __init__"},{"location":"src/classifiers/MaxPullClassifier/#set95nmaxpulls","text":"full signature: def set_nmaxpulls( self, nmaxpulls ) comments: set the nmaxpulls parameter (see also initializer)","title":"&#10551; set_nmaxpulls"},{"location":"src/classifiers/MaxPullClassifier/#train","text":"full signature: def train( self, refhist ) comments: 'train' the classifier, i.e. set the reference histogram. input arguments: - refhist: a numpy array of shape (1,nbins) or (1,nybins,nxbins)","title":"&#10551; train"},{"location":"src/classifiers/MaxPullClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the histograms based on their max bin-per-bin pull (in absolute value) with respect to a reference histogram","title":"&#10551; evaluate"},{"location":"src/classifiers/MaxPullClassifier/#getpull","text":"full signature: def getpull( self, histogram ) comments: get the pull histogram for a given test histogram input arguments: histogram: a single histogram, i.e. numpy array of shape (nbins) for 1D or (nybins,nxbins) for 2D. output: numpy array of same shape as histogram containing bin-per-bin pull w.r.t. reference histogram","title":"&#10551; getpull"},{"location":"src/classifiers/MomentClassifier/","text":"MomentClassifier [class] MomentClassifier comments: (no valid documentation found) \u2937 __init__ full signature: def __init__( self, orders=[1] ) comments: (no valid documentation found) \u2937 train full signature: def train( self, histograms ) comments: (no valid documentation found) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: (no valid documentation found) \u2937 printout full signature: def printout( self, histogram ) comments: (no valid documentation found) \u2937 save full signature: def save( self, path ) comments: save the classifier \u2937 load full signature: def load( self, path, **kwargs ) comments: get a MomentClassifier instance from a pkl file","title":"MomentClassifier"},{"location":"src/classifiers/MomentClassifier/#momentclassifier","text":"","title":"MomentClassifier"},{"location":"src/classifiers/MomentClassifier/#class-momentclassifier","text":"comments: (no valid documentation found)","title":"[class] MomentClassifier"},{"location":"src/classifiers/MomentClassifier/#9595init9595","text":"full signature: def __init__( self, orders=[1] ) comments: (no valid documentation found)","title":"&#10551; __init__"},{"location":"src/classifiers/MomentClassifier/#train","text":"full signature: def train( self, histograms ) comments: (no valid documentation found)","title":"&#10551; train"},{"location":"src/classifiers/MomentClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: (no valid documentation found)","title":"&#10551; evaluate"},{"location":"src/classifiers/MomentClassifier/#printout","text":"full signature: def printout( self, histogram ) comments: (no valid documentation found)","title":"&#10551; printout"},{"location":"src/classifiers/MomentClassifier/#save","text":"full signature: def save( self, path ) comments: save the classifier","title":"&#10551; save"},{"location":"src/classifiers/MomentClassifier/#load","text":"full signature: def load( self, path, **kwargs ) comments: get a MomentClassifier instance from a pkl file","title":"&#10551; load"},{"location":"src/classifiers/NMFClassifier/","text":"NMFClassifier Histogram classification based on nonnegative matrix factorization Specifically intended for 2D histograms, but should in principle work for 1D as well. It is basically a wrapper for a sklearn.decomposition.NMF instance. [class] NMFClassifier comments: histogram classification based on nonnegative matrix factorization specifically intended for 2D histograms, but should in principle work for 1D as well. it is basically a wrapper for a sklearn.decomposition.NMF instance. \u2937 __init__ full signature: def __init__( self, ncomponents=5, loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of NMF components (aka clusters aka basis vectors) to use in the decomposition - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.NMF \u2937 train full signature: def train( self, histograms, doplot=True, ncols=None, title=None ) comments: train the NMF model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a NMF model \u2937 set_nmax full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation \u2937 set_loss_type full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) \u2937 get_components full signature: def get_components( self ) comments: return the NMF components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins) \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the NMF reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) \u2937 save full signature: def save( self, path ) comments: save the underlying NMF model \u2937 load full signature: def load( self, path, **kwargs ) comments: get an NMFClassifier instance from a pkl file","title":"NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#nmfclassifier","text":"Histogram classification based on nonnegative matrix factorization Specifically intended for 2D histograms, but should in principle work for 1D as well. It is basically a wrapper for a sklearn.decomposition.NMF instance.","title":"NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#class-nmfclassifier","text":"comments: histogram classification based on nonnegative matrix factorization specifically intended for 2D histograms, but should in principle work for 1D as well. it is basically a wrapper for a sklearn.decomposition.NMF instance.","title":"[class] NMFClassifier"},{"location":"src/classifiers/NMFClassifier/#9595init9595","text":"full signature: def __init__( self, ncomponents=5, loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of NMF components (aka clusters aka basis vectors) to use in the decomposition - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.NMF","title":"&#10551; __init__"},{"location":"src/classifiers/NMFClassifier/#train","text":"full signature: def train( self, histograms, doplot=True, ncols=None, title=None ) comments: train the NMF model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a NMF model","title":"&#10551; train"},{"location":"src/classifiers/NMFClassifier/#set95nmax","text":"full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation","title":"&#10551; set_nmax"},{"location":"src/classifiers/NMFClassifier/#set95loss95type","text":"full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error)","title":"&#10551; set_loss_type"},{"location":"src/classifiers/NMFClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; evaluate"},{"location":"src/classifiers/NMFClassifier/#get95components","text":"full signature: def get_components( self ) comments: return the NMF components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins)","title":"&#10551; get_components"},{"location":"src/classifiers/NMFClassifier/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the NMF reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; reconstruct"},{"location":"src/classifiers/NMFClassifier/#save","text":"full signature: def save( self, path ) comments: save the underlying NMF model","title":"&#10551; save"},{"location":"src/classifiers/NMFClassifier/#load","text":"full signature: def load( self, path, **kwargs ) comments: get an NMFClassifier instance from a pkl file","title":"&#10551; load"},{"location":"src/classifiers/PCAClassifier/","text":"PCAClassifier Histogram classification based on principal component analysis It is basically a wrapper for a sklearn.decomposition.PCA instance. [class] PCAClassifier comments: histogram classification based on principal component analysis it is basically a wrapper for a sklearn.decomposition.PCA instance. \u2937 __init__ full signature: def __init__( self, ncomponents=None, svd_solver='auto', loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of PCA components (aka clusters aka basis vectors) to use in the decomposition - svd_solver: solver method to extract the PCA components note: both ncomponents and svd_solver are arguments passed down to sklearn.decomposition.PCA, see https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.PCA \u2937 train full signature: def train( self, histograms ) comments: train the PCA model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a PCA model \u2937 set_nmax full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation \u2937 set_loss_type full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) \u2937 get_components full signature: def get_components( self ) comments: return the PCA components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins) \u2937 reconstruct full signature: def reconstruct( self, histograms ) comments: return the PCA reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#pcaclassifier","text":"Histogram classification based on principal component analysis It is basically a wrapper for a sklearn.decomposition.PCA instance.","title":"PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#class-pcaclassifier","text":"comments: histogram classification based on principal component analysis it is basically a wrapper for a sklearn.decomposition.PCA instance.","title":"[class] PCAClassifier"},{"location":"src/classifiers/PCAClassifier/#9595init9595","text":"full signature: def __init__( self, ncomponents=None, svd_solver='auto', loss_type='mse', nmax=10 ) comments: initializer input arguments: - ncomponents: number of PCA components (aka clusters aka basis vectors) to use in the decomposition - svd_solver: solver method to extract the PCA components note: both ncomponents and svd_solver are arguments passed down to sklearn.decomposition.PCA, see https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error) - nmax: number of largest elements to keep in error calculation TODO: add keyword arguments to pass down to sklearn.decomposition.PCA","title":"&#10551; __init__"},{"location":"src/classifiers/PCAClassifier/#train","text":"full signature: def train( self, histograms ) comments: train the PCA model on a given set of input histograms input arguments: - histograms: a numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins) that will be used to fit a PCA model","title":"&#10551; train"},{"location":"src/classifiers/PCAClassifier/#set95nmax","text":"full signature: def set_nmax( self, nmax ) comments: set number of largest elements to keep in mean square error calculation useful to quickly re-evaluate the model with different nmax without retraining input arguments: - nmax: number of largest elements to keep in mean square error calculation","title":"&#10551; set_nmax"},{"location":"src/classifiers/PCAClassifier/#set95loss95type","text":"full signature: def set_loss_type( self, loss_type ) comments: set loss type useful to quickly re-evaluate the model with different loss without retraining input arguments: - loss_type: choose from 'mse' (mean-squared-error) or 'chi2' (chi squared error)","title":"&#10551; set_loss_type"},{"location":"src/classifiers/PCAClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classify the given histograms based on the MSE with respect to their reconstructed version input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; evaluate"},{"location":"src/classifiers/PCAClassifier/#get95components","text":"full signature: def get_components( self ) comments: return the PCA components (aka cluster centers aka basis vectors) output: a numpy array of shape (ncomponents,nbins) or (ncomponents,nybins,nxbins)","title":"&#10551; get_components"},{"location":"src/classifiers/PCAClassifier/#reconstruct","text":"full signature: def reconstruct( self, histograms ) comments: return the PCA reconstruction for a given set of histograms input arguments: - histograms: numpy array of shape (nhists,nbins) or (nhists,nybins,nxbins)","title":"&#10551; reconstruct"},{"location":"src/classifiers/TemplateBasedClassifier/","text":"TemplateBasedClassifier Histogram classifier based on a direct comparison with templates (i.e. reference histograms) mseTopN_templates full signature: def mseTopN_templates( histograms, templates, n=-1 ) comments: calculate the mse between each histogram in histograms and each histogram in templates input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 2D numpy array of shape (nhistograms,ntemplates) holding the mseTopN between each mseTopN_min full signature: def mseTopN_min( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the minimum input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the minimum mseTopN for each histogram mseTop10_min full signature: def mseTop10_min( histograms, templates ) comments: special case of above with n=10 mseTopN_avg full signature: def mseTopN_avg( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the average input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the average mseTopN for each histogram mseTop10_avg full signature: def mseTop10_avg( histograms, templates ) comments: special case of above with n=10 [class] TemplateBasedClassifier comments: histogram classifier based on a direct comparison with templates (i.e. reference histograms) \u2937 __init__ full signature: def __init__( self, comparemethod='minmse' ) comments: initializer input arguments: - comparemethod: string representing the method by which to compare a histogram with a set of templates currently supported methods are: - minmse: minimum mean square error between histogram and all templates - avgmse: average mean square error between histogram and all templates \u2937 train full signature: def train( self, templates ) comments: 'train' the classifier, i.e. set the templates (reference histograms) input arguments: - templates: a 2D numpy array of shape (nhistograms,nbins) \u2937 evaluate full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their deviation from templates \u2937 save full signature: def save( self, path ) comments: save the classifier \u2937 load full signature: def load( self, path, **kwargs ) comments: get a TemplateBasedClassifier instance from a pkl file","title":"TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#templatebasedclassifier","text":"Histogram classifier based on a direct comparison with templates (i.e. reference histograms)","title":"TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95templates","text":"full signature: def mseTopN_templates( histograms, templates, n=-1 ) comments: calculate the mse between each histogram in histograms and each histogram in templates input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 2D numpy array of shape (nhistograms,ntemplates) holding the mseTopN between each","title":"mseTopN_templates"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95min","text":"full signature: def mseTopN_min( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the minimum input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the minimum mseTopN for each histogram","title":"mseTopN_min"},{"location":"src/classifiers/TemplateBasedClassifier/#msetop1095min","text":"full signature: def mseTop10_min( histograms, templates ) comments: special case of above with n=10","title":"mseTop10_min"},{"location":"src/classifiers/TemplateBasedClassifier/#msetopn95avg","text":"full signature: def mseTopN_avg( histograms, templates, n=-1 ) comments: calculate the mse betwee a histogram and each template and return the average input arguments: - histograms: 2D numpy array of shape (nhistograms, nbins) - templates: 2D numpy array of shape (ntemplates,nbins) - n: integer representing the number of (sorted) bin squared errors to take into account (default: all) output: 1D numpy array of shape (nhistograms) holding the average mseTopN for each histogram","title":"mseTopN_avg"},{"location":"src/classifiers/TemplateBasedClassifier/#msetop1095avg","text":"full signature: def mseTop10_avg( histograms, templates ) comments: special case of above with n=10","title":"mseTop10_avg"},{"location":"src/classifiers/TemplateBasedClassifier/#class-templatebasedclassifier","text":"comments: histogram classifier based on a direct comparison with templates (i.e. reference histograms)","title":"[class] TemplateBasedClassifier"},{"location":"src/classifiers/TemplateBasedClassifier/#9595init9595","text":"full signature: def __init__( self, comparemethod='minmse' ) comments: initializer input arguments: - comparemethod: string representing the method by which to compare a histogram with a set of templates currently supported methods are: - minmse: minimum mean square error between histogram and all templates - avgmse: average mean square error between histogram and all templates","title":"&#10551; __init__"},{"location":"src/classifiers/TemplateBasedClassifier/#train","text":"full signature: def train( self, templates ) comments: 'train' the classifier, i.e. set the templates (reference histograms) input arguments: - templates: a 2D numpy array of shape (nhistograms,nbins)","title":"&#10551; train"},{"location":"src/classifiers/TemplateBasedClassifier/#evaluate","text":"full signature: def evaluate( self, histograms ) comments: classification of a collection of histograms based on their deviation from templates","title":"&#10551; evaluate"},{"location":"src/classifiers/TemplateBasedClassifier/#save","text":"full signature: def save( self, path ) comments: save the classifier","title":"&#10551; save"},{"location":"src/classifiers/TemplateBasedClassifier/#load","text":"full signature: def load( self, path, **kwargs ) comments: get a TemplateBasedClassifier instance from a pkl file","title":"&#10551; load"},{"location":"src/cloudfitters/CloudFitter/","text":"CloudFitter Abstract base class for all point cloud fitting algorithms Note that all concrete point cloud fitters must inherit from CloudFitter! How to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples! [class] CloudFitter comments: abstract base class for all point cloud fitting algorithms note that all concrete point cloud fitters must inherit from CloudFitter! how to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples! \u2937 __init__ full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class! \u2937 fit full signature: def fit( self, points ) comments: input arguments: - points: 2D numpy array of shape (npoints,ndims) \u2937 pdf full signature: def pdf( self, points ) comments: evaluate the pdf (probability density function) at given points this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: a 2D numpy array of shape (npoints,ndims) output: a 1D array of shape (npoints)","title":"CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#cloudfitter","text":"Abstract base class for all point cloud fitting algorithms Note that all concrete point cloud fitters must inherit from CloudFitter! How to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary See also the existing examples!","title":"CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#class-cloudfitter","text":"comments: abstract base class for all point cloud fitting algorithms note that all concrete point cloud fitters must inherit from CloudFitter! how to make a concrete CloudFitter class: - define a class that inherits from CloudFitter - make sure all functions with @abstractmethod are implemented in your class - it is recommended to start each overriding function with a call to super(), but this is not strictly necessary see also the existing examples!","title":"[class] CloudFitter"},{"location":"src/cloudfitters/CloudFitter/#9595init9595","text":"full signature: def __init__( self ) comments: empty intializer this is an @abstractmethod and must be overridden in any concrete deriving class!","title":"&#10551; __init__"},{"location":"src/cloudfitters/CloudFitter/#fit","text":"full signature: def fit( self, points ) comments: input arguments: - points: 2D numpy array of shape (npoints,ndims)","title":"&#10551; fit"},{"location":"src/cloudfitters/CloudFitter/#pdf","text":"full signature: def pdf( self, points ) comments: evaluate the pdf (probability density function) at given points this is an @abstractmethod and must be overridden in any concrete deriving class! input arguments: - points: a 2D numpy array of shape (npoints,ndims) output: a 1D array of shape (npoints)","title":"&#10551; pdf"},{"location":"src/cloudfitters/ExponentialFitter/","text":"ExponentialFitter Class for fitting an exponential distribution to a point cloud An exponential distribution in N dimensions is fully determined by an N-dimensional vector, representing the N-dimensional decay parameter (or lambda parameter) of the distribution. [class] ExponentialFitter comments: class for fitting an exponential distribution to a point cloud parameters - l: multidimensional lambda parameter of exponential \u2937 __init__ full signature: def __init__(self) comments: empty constructor input arguments: - points: a np array of shape (npoints,ndims) \u2937 fit full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points","title":"ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#exponentialfitter","text":"Class for fitting an exponential distribution to a point cloud An exponential distribution in N dimensions is fully determined by an N-dimensional vector, representing the N-dimensional decay parameter (or lambda parameter) of the distribution.","title":"ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#class-exponentialfitter","text":"comments: class for fitting an exponential distribution to a point cloud parameters - l: multidimensional lambda parameter of exponential","title":"[class] ExponentialFitter"},{"location":"src/cloudfitters/ExponentialFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; __init__"},{"location":"src/cloudfitters/ExponentialFitter/#fit","text":"full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; fit"},{"location":"src/cloudfitters/ExponentialFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/GaussianKdeFitter/","text":"GaussianKdeFitter Class for fitting a gaussian kernel density to a point cloud Basically a wrapper for scipy.stats.gaussian_kde. A gaussian kernel density can be thought of as a sum of little (potentially multidimensional) gaussians, each one centered at one of the points in the cloud. Hence, the resulting distribution is a sort of smoothed version of the discrete point cloud. [class] GaussianKdeFitter comments: class for fitting a gaussian kernel density to a point cloud basically a wrapper for scipy.stats.gaussian_kde. parameters - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance) \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self, points, bw_method='scott', bw_scott_factor=None) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott' \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points","title":"GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#gaussiankdefitter","text":"Class for fitting a gaussian kernel density to a point cloud Basically a wrapper for scipy.stats.gaussian_kde. A gaussian kernel density can be thought of as a sum of little (potentially multidimensional) gaussians, each one centered at one of the points in the cloud. Hence, the resulting distribution is a sort of smoothed version of the discrete point cloud.","title":"GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#class-gaussiankdefitter","text":"comments: class for fitting a gaussian kernel density to a point cloud basically a wrapper for scipy.stats.gaussian_kde. parameters - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance)","title":"[class] GaussianKdeFitter"},{"location":"src/cloudfitters/GaussianKdeFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/GaussianKdeFitter/#fit","text":"full signature: def fit(self, points, bw_method='scott', bw_scott_factor=None) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott'","title":"&#10551; fit"},{"location":"src/cloudfitters/GaussianKdeFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/HyperRectangleFitter/","text":"HyperRectangleFitter Simple fitter making a hard cut in each dimension calculate_cut_values full signature: def calculate_cut_values( values, quantile, side='both' ) comments: calculate the appropriate cut values to discard a given quantile of values input arguments: - values: a 1D numpy array - quantile: quantile of values to discard, a float between 0 and 1 (or between 0 and 0.5 for side='both') - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. returns: - a tuple of shape (lower cut, upper cut), with None entries if not applicable [class] HyperRectangleFitter comments: Simple fitter making a hard cut in each dimension \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self, points, quantiles=0, side='both', verbose=False) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - quantiles: quantiles of values to discard. can either be a float between 0 and 1 (applied in all dimensions), or a list of such floats with same length as number of dimensions in points. (note: for side='both', quantiles above 0.5 will discard everything) - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. \u2937 apply_cuts full signature: def apply_cuts(self, point) comments: apply the cuts to a point and return whether it passes them input arguments: - point: a 1D numpy array of shape (ndims,) returns: - boolean \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points note that the pdf is either 0 (does not pass cuts) or 1 (passes cuts)","title":"HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#hyperrectanglefitter","text":"Simple fitter making a hard cut in each dimension","title":"HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#calculate95cut95values","text":"full signature: def calculate_cut_values( values, quantile, side='both' ) comments: calculate the appropriate cut values to discard a given quantile of values input arguments: - values: a 1D numpy array - quantile: quantile of values to discard, a float between 0 and 1 (or between 0 and 0.5 for side='both') - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end. returns: - a tuple of shape (lower cut, upper cut), with None entries if not applicable","title":"calculate_cut_values"},{"location":"src/cloudfitters/HyperRectangleFitter/#class-hyperrectanglefitter","text":"comments: Simple fitter making a hard cut in each dimension","title":"[class] HyperRectangleFitter"},{"location":"src/cloudfitters/HyperRectangleFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/HyperRectangleFitter/#fit","text":"full signature: def fit(self, points, quantiles=0, side='both', verbose=False) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - quantiles: quantiles of values to discard. can either be a float between 0 and 1 (applied in all dimensions), or a list of such floats with same length as number of dimensions in points. (note: for side='both', quantiles above 0.5 will discard everything) - side: either 'both', 'down' or 'up' for 'up', the cut will discard the quantile highest values, for 'down', cut will discard the quantile lowest values, for 'both', the cut(s) will discard the quantile values both at the high and low end.","title":"&#10551; fit"},{"location":"src/cloudfitters/HyperRectangleFitter/#apply95cuts","text":"full signature: def apply_cuts(self, point) comments: apply the cuts to a point and return whether it passes them input arguments: - point: a 1D numpy array of shape (ndims,) returns: - boolean","title":"&#10551; apply_cuts"},{"location":"src/cloudfitters/HyperRectangleFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points note that the pdf is either 0 (does not pass cuts) or 1 (passes cuts)","title":"&#10551; pdf"},{"location":"src/cloudfitters/IdentityFitter/","text":"IdentityFitter Class for using classifier scores directly as global scores [class] IdentityFitter comments: class for propagating classifier output scores (e.g. MSE) to global lumisection score \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a numpy array of shape (npoints,ndims) note that ndims is supposed to be 1, else this type of classifier is not well defined. \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points \u2937 save full signature: def save(self, path) comments: save this fitter (dummy for now since nothing to be saved) \u2937 load full signature: def load(self, path) comments: load this fitter (dummy for now since nothing to be loaded)","title":"IdentityFitter"},{"location":"src/cloudfitters/IdentityFitter/#identityfitter","text":"Class for using classifier scores directly as global scores","title":"IdentityFitter"},{"location":"src/cloudfitters/IdentityFitter/#class-identityfitter","text":"comments: class for propagating classifier output scores (e.g. MSE) to global lumisection score","title":"[class] IdentityFitter"},{"location":"src/cloudfitters/IdentityFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/IdentityFitter/#fit","text":"full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a numpy array of shape (npoints,ndims) note that ndims is supposed to be 1, else this type of classifier is not well defined.","title":"&#10551; fit"},{"location":"src/cloudfitters/IdentityFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/IdentityFitter/#save","text":"full signature: def save(self, path) comments: save this fitter (dummy for now since nothing to be saved)","title":"&#10551; save"},{"location":"src/cloudfitters/IdentityFitter/#load","text":"full signature: def load(self, path) comments: load this fitter (dummy for now since nothing to be loaded)","title":"&#10551; load"},{"location":"src/cloudfitters/LogNormalFitter/","text":"LogNormalFitter Class for fitting a log-normal distribution to a point cloud A log-normal distribution is constructed by fitting a normal distribution to the logarithm of the point coordinates. [class] LogNormalFitter comments: class for fitting a log-normal distribution to a point cloud parameters: - mean: multidim mean of underlying normal - cov: multidim covariance matrix of underlying normal - mvn: scipy.stats multivariate_normal object built from the mean and cov \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points","title":"LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#lognormalfitter","text":"Class for fitting a log-normal distribution to a point cloud A log-normal distribution is constructed by fitting a normal distribution to the logarithm of the point coordinates.","title":"LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#class-lognormalfitter","text":"comments: class for fitting a log-normal distribution to a point cloud parameters: - mean: multidim mean of underlying normal - cov: multidim covariance matrix of underlying normal - mvn: scipy.stats multivariate_normal object built from the mean and cov","title":"[class] LogNormalFitter"},{"location":"src/cloudfitters/LogNormalFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/LogNormalFitter/#fit","text":"full signature: def fit(self, points) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; fit"},{"location":"src/cloudfitters/LogNormalFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points","title":"&#10551; pdf"},{"location":"src/cloudfitters/PCAGaussianFitter/","text":"PCAGaussianFitter Class for fitting a multidimensional gaussian distribution to a PCA-reduced point cloud Instead of fitting the full (high-dimensional) point cloud, a PCA-based dimensionality reduction is first applied on it. This has the advantage that the fit can be visualised correctly (in case of 2 reduced dimensions), instead of only projections of it. The potential disadvantage is that the PCA reduction might distort the relative separations. [class] PCAGaussianFitter comments: class for fitting a gaussian distribution to a PCA-reduced point cloud parameters - pca: sklearn.decomposition.pca object - mean: multidim mean of normal distribution - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from mean and cov \u2937 __init__ full signature: def __init__(self) comments: empty constructor input arguments: \u2937 fit full signature: def fit(self, points, npcadims=2) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - npcadims: number of PCA compoments to keep \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points note: points can be both of shape (npoints,ndims) or of shape (npoints,npcadims); in the latter case it is assumed that the points are already PCA-transformed, and only the gaussian kernel density is applied on them. \u2937 transform full signature: def transform(self, points) comments: perform PCA transformation","title":"PCAGaussianFitter"},{"location":"src/cloudfitters/PCAGaussianFitter/#pcagaussianfitter","text":"Class for fitting a multidimensional gaussian distribution to a PCA-reduced point cloud Instead of fitting the full (high-dimensional) point cloud, a PCA-based dimensionality reduction is first applied on it. This has the advantage that the fit can be visualised correctly (in case of 2 reduced dimensions), instead of only projections of it. The potential disadvantage is that the PCA reduction might distort the relative separations.","title":"PCAGaussianFitter"},{"location":"src/cloudfitters/PCAGaussianFitter/#class-pcagaussianfitter","text":"comments: class for fitting a gaussian distribution to a PCA-reduced point cloud parameters - pca: sklearn.decomposition.pca object - mean: multidim mean of normal distribution - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from mean and cov","title":"[class] PCAGaussianFitter"},{"location":"src/cloudfitters/PCAGaussianFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor input arguments:","title":"&#10551; __init__"},{"location":"src/cloudfitters/PCAGaussianFitter/#fit","text":"full signature: def fit(self, points, npcadims=2) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - npcadims: number of PCA compoments to keep","title":"&#10551; fit"},{"location":"src/cloudfitters/PCAGaussianFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points note: points can be both of shape (npoints,ndims) or of shape (npoints,npcadims); in the latter case it is assumed that the points are already PCA-transformed, and only the gaussian kernel density is applied on them.","title":"&#10551; pdf"},{"location":"src/cloudfitters/PCAGaussianFitter/#transform","text":"full signature: def transform(self, points) comments: perform PCA transformation","title":"&#10551; transform"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/","text":"PCAGaussianKdeFitter Class for fitting a gaussian kernel density to a PCA-reduced point cloud Extension of GaussianKdeFitter: instead of fitting the full point cloud, a PCA-based dimensionality reduction is first applied on it. This has the advantage that the fit can be visualised correctly (in case of 2 reduced dimensions), instead of only projections of it. The potential disadvantage is that the PCA reduction might distort the relative separations. [class] PCAGaussianKdeFitter comments: class for fitting a gaussian kernel density to a PCA-reduced point cloud basically a wrapper for sklean.decomposition.PCA + scipy.stats.gaussian_kde. parameters - pca: sklearn.decomposition.pca object - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance) \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self, points, npcadims=2, bw_method='scott', bw_scott_factor=None) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - npcadims: number of PCA compoments to keep - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott' \u2937 pdf full signature: def pdf(self, points) comments: get pdf at points note: points can be both of shape (npoints,ndims) or of shape (npoints,npcadims); in the latter case it is assumed that the points are already PCA-transformed, and only the gaussian kernel density is applied on them. \u2937 transform full signature: def transform(self, points) comments: perform PCA transformation","title":"PCAGaussianKdeFitter"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#pcagaussiankdefitter","text":"Class for fitting a gaussian kernel density to a PCA-reduced point cloud Extension of GaussianKdeFitter: instead of fitting the full point cloud, a PCA-based dimensionality reduction is first applied on it. This has the advantage that the fit can be visualised correctly (in case of 2 reduced dimensions), instead of only projections of it. The potential disadvantage is that the PCA reduction might distort the relative separations.","title":"PCAGaussianKdeFitter"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#class-pcagaussiankdefitter","text":"comments: class for fitting a gaussian kernel density to a PCA-reduced point cloud basically a wrapper for sklean.decomposition.PCA + scipy.stats.gaussian_kde. parameters - pca: sklearn.decomposition.pca object - kernel: scipy.stats.gaussian_kde object - cov: covariance matrix (use np.cov for now, maybe later replace by internal kernel.covariance)","title":"[class] PCAGaussianKdeFitter"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#fit","text":"full signature: def fit(self, points, npcadims=2, bw_method='scott', bw_scott_factor=None) comments: fit to a set of points input arguments: - points: a np array of shape (npoints,ndims) - npcadims: number of PCA compoments to keep - bw_method: method to calculate the bandwidth of the gaussians, see https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.gaussian_kde.html - bw_scott_factor: additional multiplication factor applied to bandwidth in case it is set to 'scott'","title":"&#10551; fit"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#pdf","text":"full signature: def pdf(self, points) comments: get pdf at points note: points can be both of shape (npoints,ndims) or of shape (npoints,npcadims); in the latter case it is assumed that the points are already PCA-transformed, and only the gaussian kernel density is applied on them.","title":"&#10551; pdf"},{"location":"src/cloudfitters/PCAGaussianKdeFitter/#transform","text":"full signature: def transform(self, points) comments: perform PCA transformation","title":"&#10551; transform"},{"location":"src/cloudfitters/SeminormalFitter/","text":"SeminormalFitter Class for fitting a 'seminormal' distribution to a point cloud This is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. [class] SeminormalFitter comments: class for fitting a 'seminormal' distribution to a point cloud this is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. parameters - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from the cov \u2937 __init__ full signature: def __init__(self) comments: empty constructor \u2937 fit full signature: def fit(self,points) comments: make the fit input arguments: - points: a np array of shape (npoints,ndims) \u2937 pdf full signature: def pdf(self,points) comments: get pdf at points input arguments: - points: a np array of shape (npoints,ndims) \u2937 save full signature: def save(self,path) comments: save the covariance matrix as a .npy file specified by path \u2937 load full signature: def load(self,path) comments: load a covariance matrix from a .npy file specified by path and build the fit from it","title":"SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#seminormalfitter","text":"Class for fitting a 'seminormal' distribution to a point cloud This is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin.","title":"SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#class-seminormalfitter","text":"comments: class for fitting a 'seminormal' distribution to a point cloud this is not strictly speaking a probability distribution, only the first quadrant of the result of fitting a normal distribution to the data + its mirror image wrt the origin. parameters - cov: multidim covariance matrix of normal distribution - mvn: scipy.stats multivariate_normal object built from the cov","title":"[class] SeminormalFitter"},{"location":"src/cloudfitters/SeminormalFitter/#9595init9595","text":"full signature: def __init__(self) comments: empty constructor","title":"&#10551; __init__"},{"location":"src/cloudfitters/SeminormalFitter/#fit","text":"full signature: def fit(self,points) comments: make the fit input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; fit"},{"location":"src/cloudfitters/SeminormalFitter/#pdf","text":"full signature: def pdf(self,points) comments: get pdf at points input arguments: - points: a np array of shape (npoints,ndims)","title":"&#10551; pdf"},{"location":"src/cloudfitters/SeminormalFitter/#save","text":"full signature: def save(self,path) comments: save the covariance matrix as a .npy file specified by path","title":"&#10551; save"},{"location":"src/cloudfitters/SeminormalFitter/#load","text":"full signature: def load(self,path) comments: load a covariance matrix from a .npy file specified by path and build the fit from it","title":"&#10551; load"},{"location":"utils/","text":"Collection of utility functions","title":"README"},{"location":"utils/autoencoder_utils/","text":"autoencoder utils Utilities related to the training and evaluation of autoencoder models with keras The functionality in this script includes: - definition of loss functions (several flavours of MSE or chi-squared) - calculating and plotting ROC curves and confusion matrices - definition of very simple ready-to-use keras model architectures mseTop10 full signature: def mseTop10(y_true, y_pred) comments: MSE top 10 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - mean squared error between y_true and y_pred, where only the 10 bins with largest squared error are taken into account. if y_true and y_pred are 2D arrays, this function returns 1D array (mseTop10 for each histogram) mseTop10Raw full signature: def mseTop10Raw(y_true, y_pred) comments: same as mseTop10 but without using tf or K the version including tf or K seemed to cause randomly dying kernels, no clear reason could be found, but it was solved using this loss function instead. verified that it gives exactly the same output as the function above on some random arrays. contrary to mseTop10, this function only works for arrays with 2D shapes (so shape (nhists,nbins)), not for (nbins,). mseTopNRaw full signature: def mseTopNRaw(y_true, y_pred, n=10) comments: generalization of mseTop10Raw to any number of bins to take into account note: now generalized to also work for 2D histograms, i.e. arrays of shape (nhists,nybins,nxbins)! hence this is the most general method and preferred above mseTop10 and mseTop10Raw, which are only kept for reference input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for averaging output: numpy array of shape (nhists) chiSquared full signature: def chiSquared(y_true, y_pred) comments: chi2 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - relative mean squared error between y_true and y_pred, if y_true and y_pred are 2D arrays, this function returns 1D array (chiSquared for each histogram) chiSquaredTopNRaw full signature: def chiSquaredTopNRaw(y_true, y_pred, n=10) comments: generalization of chiSquared to any number of bins to take into account note: should work for 2D histograms as well (i.e. arrays of shape (nhistograms,nybins,nxbins)), but not yet tested! input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for summing output: numpy array of shape (nhists) calculate_roc full signature: def calculate_roc(scores, labels, scoreax) comments: calculate a roc curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - scoreax is an array of score thresholds for which to compute the signal and background efficiency, assumed to be sorted in increasing order (i.e. from loose to tight) output: - tuple of two np arrays (signal efficiency and background efficiency) get_roc full signature: def get_roc(scores, labels, mode='lin', npoints=100, doprint=False, doplot=True, doshow=True, bootstrap_samples=None, bootstrap_size=None, returneffs=False ) comments: make a ROC curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - mode: how to determine the points where to calculate signal and background efficiencies; options are: - 'lin': np.linspace between min and max score - 'geom': np. geomspace between min and max score - 'full': one point per score instance - npoints: number of points where to calculate the signal and background efficiencies (ignored if mode is 'full') - doprint: boolean whether to print score thresholds and corresponding signal and background efficiencies - doplot: boolean whether to make a plot - doshow: boolean whether to call plt.show - bootstrap_samples: number of bootstrap samples to assess uncertainty on ROC curve (default: no bootstrapping) - bootstrap_size: size of each bootstrap sample (default: same size as scores, i.e. full sample size) note: the bootstrapping method can be used to assess the uncertainty on the ROC curve, by recalculating it several times on samples drawn from the test set with replacement; the resulting uncertainty as calculated here does not include contributions from varying the training set! - returneffs: boolean whether to return the signal and background efficiencies returns: - if returneffs is False, only the AUC value is returned - if returneffs is True, the return type is a tuple of the form (auc,sigeff,bckeff) get_roc_from_hists full signature: def get_roc_from_hists(hists, labels, predicted_hists, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic') comments: make a ROC curve without manually calculating the scores the output score is the mseTop10Raw between the histograms and their reconstruction - input arguments: - hists and predicted_hists are 2D numpy arrays of shape (nhistograms,nbins) - other arguments: see get_roc get_confusion_matrix full signature: def get_confusion_matrix(scores, labels, wp='maxauc', plotwp=True, true_positive_label='Good', true_negative_label='Anomalous', pred_positive_label='Predicted good', pred_negative_label='Predicted anomalous', xaxlabelsize=None, yaxlabelsize=None, textsize=None, colormap='Blues', colortitle=None) comments: plot a confusion matrix input arguments: - scores and labels: defined in the same way as for get_roc - wp: the chosen working point (i.e. any score above wp is flagged as signal, any below is flagged as background) note: wp can be a integer or float, in which case that value will be used directly, or it can be a string in which case it will be used as the 'method' argument in get_wp! - plotwp: only relevant if wp is a string (see above), in which case plotwp will be used as the 'doplot' argument in get_wp get_confusion_matrix_from_hists full signature: def get_confusion_matrix_from_hists(hists, labels, predicted_hists, msewp=None) comments: plot a confusion matrix without manually calculating the scores the output score is the mse between the histograms and their reconstruction get_wp full signature: def get_wp(scores, labels, method='maxauc', doplot=False) comments: automatically calculate a suitable working point input arguments: - scores, labels: equally long 1d numpy arrays of predictions and true labels respectively note: in all methods, the labels are assumed to be 0 (for background) or 1 (for signal)! - method: method to calculate the working point currently supported: 'maxauc' - doplot: make a plot (if a plotting method exists for the chosen method) get_wp_maxauc full signature: def get_wp_maxauc(scores, labels, doplot=False) comments: calculate the working point corresponding to maximum pseudo-AUC (i.e. maximize the rectangular area enclosed by the working point) getautoencoder full signature: def getautoencoder(input_size,arch,act=[],opt='adam',loss=mseTop10) comments: get a trainable autoencoder model input args: - input_size: size of vector that autoencoder will operate on - arch: list of number of nodes per hidden layer (excluding input and output layer) - act: list of activations per layer (default: tanh) - opt: optimizer to use (default: adam) - loss: loss function to use (defualt: mseTop10) train_simple_autoencoder full signature: def train_simple_autoencoder(hists, nepochs=-1, modelname='', batch_size=500, shuffle=False, verbose=1, validation_split=0.1, returnhistory=False ) comments: create and train a very simple keras model the model consists of one hidden layer (with half as many units as there are input bins), tanh activation, adam optimizer and mseTop10 loss. input args: - hists is a 2D numpy array of shape (nhistograms, nbins) - nepochs is the number of epochs to use (has a default value if left unspecified) - modelname is a file name to save the model in (default: model is not saved to a file) - batch_size, shuffle, verbose, validation_split: passed to keras .fit method - returnhistory: boolean whether to return the training history (e.g. for making plots) returns - if returnhistory is False, only the trained keras model is returned - if returnhistory is True, the return type is a tuple of the form (model, history) clip_scores full signature: def clip_scores( scores, margin=1., hard_thresholds=None ) comments: clip +-inf values in scores +inf values in scores will be replaced by the maximum value (exclucing +inf) plus one -inf values in scores will be replaced by the minimim value (exclucing -inf) minus one input arguments: - scores: 1D numpy array - margin: margin between maximum value (excluding inf) and where to put inf. - hard_thresholds: tuple of values for -inf, +inf (in case the min or max cannot be determined) returns - array with same length as scores with elements replaced as explained above","title":"autoencoder_utils"},{"location":"utils/autoencoder_utils/#autoencoder-utils","text":"Utilities related to the training and evaluation of autoencoder models with keras The functionality in this script includes: - definition of loss functions (several flavours of MSE or chi-squared) - calculating and plotting ROC curves and confusion matrices - definition of very simple ready-to-use keras model architectures","title":"autoencoder utils"},{"location":"utils/autoencoder_utils/#msetop10","text":"full signature: def mseTop10(y_true, y_pred) comments: MSE top 10 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - mean squared error between y_true and y_pred, where only the 10 bins with largest squared error are taken into account. if y_true and y_pred are 2D arrays, this function returns 1D array (mseTop10 for each histogram)","title":"mseTop10"},{"location":"utils/autoencoder_utils/#msetop10raw","text":"full signature: def mseTop10Raw(y_true, y_pred) comments: same as mseTop10 but without using tf or K the version including tf or K seemed to cause randomly dying kernels, no clear reason could be found, but it was solved using this loss function instead. verified that it gives exactly the same output as the function above on some random arrays. contrary to mseTop10, this function only works for arrays with 2D shapes (so shape (nhists,nbins)), not for (nbins,).","title":"mseTop10Raw"},{"location":"utils/autoencoder_utils/#msetopnraw","text":"full signature: def mseTopNRaw(y_true, y_pred, n=10) comments: generalization of mseTop10Raw to any number of bins to take into account note: now generalized to also work for 2D histograms, i.e. arrays of shape (nhists,nybins,nxbins)! hence this is the most general method and preferred above mseTop10 and mseTop10Raw, which are only kept for reference input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for averaging output: numpy array of shape (nhists)","title":"mseTopNRaw"},{"location":"utils/autoencoder_utils/#chisquared","text":"full signature: def chiSquared(y_true, y_pred) comments: chi2 loss function for autoencoder training input arguments: - y_true and y_pred: two numpy arrays of equal shape, typically a histogram and its autoencoder reconstruction. if two-dimensional, the arrays are assumed to have shape (nhists,nbins)! output: - relative mean squared error between y_true and y_pred, if y_true and y_pred are 2D arrays, this function returns 1D array (chiSquared for each histogram)","title":"chiSquared"},{"location":"utils/autoencoder_utils/#chisquaredtopnraw","text":"full signature: def chiSquaredTopNRaw(y_true, y_pred, n=10) comments: generalization of chiSquared to any number of bins to take into account note: should work for 2D histograms as well (i.e. arrays of shape (nhistograms,nybins,nxbins)), but not yet tested! input arguments: - y_true, y_pred: numpy arrays between which to calculate the mean square difference, of shape (nhists,nbins) or (nhists,nybins,nxbins) - n: number of largest elements to keep for summing output: numpy array of shape (nhists)","title":"chiSquaredTopNRaw"},{"location":"utils/autoencoder_utils/#calculate95roc","text":"full signature: def calculate_roc(scores, labels, scoreax) comments: calculate a roc curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - scoreax is an array of score thresholds for which to compute the signal and background efficiency, assumed to be sorted in increasing order (i.e. from loose to tight) output: - tuple of two np arrays (signal efficiency and background efficiency)","title":"calculate_roc"},{"location":"utils/autoencoder_utils/#get95roc","text":"full signature: def get_roc(scores, labels, mode='lin', npoints=100, doprint=False, doplot=True, doshow=True, bootstrap_samples=None, bootstrap_size=None, returneffs=False ) comments: make a ROC curve input arguments: - scores is a 1D numpy array containing output scores of any algorithm - labels is a 1D numpy array (equally long as scores) containing labels note that 1 for signal and 0 for background is assumed! this convention is only used to define what scores belong to signal or background; the scores itself can be anything (not limited to (0,1)), as long as the target for signal is higher than the target for background - mode: how to determine the points where to calculate signal and background efficiencies; options are: - 'lin': np.linspace between min and max score - 'geom': np. geomspace between min and max score - 'full': one point per score instance - npoints: number of points where to calculate the signal and background efficiencies (ignored if mode is 'full') - doprint: boolean whether to print score thresholds and corresponding signal and background efficiencies - doplot: boolean whether to make a plot - doshow: boolean whether to call plt.show - bootstrap_samples: number of bootstrap samples to assess uncertainty on ROC curve (default: no bootstrapping) - bootstrap_size: size of each bootstrap sample (default: same size as scores, i.e. full sample size) note: the bootstrapping method can be used to assess the uncertainty on the ROC curve, by recalculating it several times on samples drawn from the test set with replacement; the resulting uncertainty as calculated here does not include contributions from varying the training set! - returneffs: boolean whether to return the signal and background efficiencies returns: - if returneffs is False, only the AUC value is returned - if returneffs is True, the return type is a tuple of the form (auc,sigeff,bckeff)","title":"get_roc"},{"location":"utils/autoencoder_utils/#get95roc95from95hists","text":"full signature: def get_roc_from_hists(hists, labels, predicted_hists, mode='lin', npoints=100, doprint=False, doplot=True, plotmode='classic') comments: make a ROC curve without manually calculating the scores the output score is the mseTop10Raw between the histograms and their reconstruction - input arguments: - hists and predicted_hists are 2D numpy arrays of shape (nhistograms,nbins) - other arguments: see get_roc","title":"get_roc_from_hists"},{"location":"utils/autoencoder_utils/#get95confusion95matrix","text":"full signature: def get_confusion_matrix(scores, labels, wp='maxauc', plotwp=True, true_positive_label='Good', true_negative_label='Anomalous', pred_positive_label='Predicted good', pred_negative_label='Predicted anomalous', xaxlabelsize=None, yaxlabelsize=None, textsize=None, colormap='Blues', colortitle=None) comments: plot a confusion matrix input arguments: - scores and labels: defined in the same way as for get_roc - wp: the chosen working point (i.e. any score above wp is flagged as signal, any below is flagged as background) note: wp can be a integer or float, in which case that value will be used directly, or it can be a string in which case it will be used as the 'method' argument in get_wp! - plotwp: only relevant if wp is a string (see above), in which case plotwp will be used as the 'doplot' argument in get_wp","title":"get_confusion_matrix"},{"location":"utils/autoencoder_utils/#get95confusion95matrix95from95hists","text":"full signature: def get_confusion_matrix_from_hists(hists, labels, predicted_hists, msewp=None) comments: plot a confusion matrix without manually calculating the scores the output score is the mse between the histograms and their reconstruction","title":"get_confusion_matrix_from_hists"},{"location":"utils/autoencoder_utils/#get95wp","text":"full signature: def get_wp(scores, labels, method='maxauc', doplot=False) comments: automatically calculate a suitable working point input arguments: - scores, labels: equally long 1d numpy arrays of predictions and true labels respectively note: in all methods, the labels are assumed to be 0 (for background) or 1 (for signal)! - method: method to calculate the working point currently supported: 'maxauc' - doplot: make a plot (if a plotting method exists for the chosen method)","title":"get_wp"},{"location":"utils/autoencoder_utils/#get95wp95maxauc","text":"full signature: def get_wp_maxauc(scores, labels, doplot=False) comments: calculate the working point corresponding to maximum pseudo-AUC (i.e. maximize the rectangular area enclosed by the working point)","title":"get_wp_maxauc"},{"location":"utils/autoencoder_utils/#getautoencoder","text":"full signature: def getautoencoder(input_size,arch,act=[],opt='adam',loss=mseTop10) comments: get a trainable autoencoder model input args: - input_size: size of vector that autoencoder will operate on - arch: list of number of nodes per hidden layer (excluding input and output layer) - act: list of activations per layer (default: tanh) - opt: optimizer to use (default: adam) - loss: loss function to use (defualt: mseTop10)","title":"getautoencoder"},{"location":"utils/autoencoder_utils/#train95simple95autoencoder","text":"full signature: def train_simple_autoencoder(hists, nepochs=-1, modelname='', batch_size=500, shuffle=False, verbose=1, validation_split=0.1, returnhistory=False ) comments: create and train a very simple keras model the model consists of one hidden layer (with half as many units as there are input bins), tanh activation, adam optimizer and mseTop10 loss. input args: - hists is a 2D numpy array of shape (nhistograms, nbins) - nepochs is the number of epochs to use (has a default value if left unspecified) - modelname is a file name to save the model in (default: model is not saved to a file) - batch_size, shuffle, verbose, validation_split: passed to keras .fit method - returnhistory: boolean whether to return the training history (e.g. for making plots) returns - if returnhistory is False, only the trained keras model is returned - if returnhistory is True, the return type is a tuple of the form (model, history)","title":"train_simple_autoencoder"},{"location":"utils/autoencoder_utils/#clip95scores","text":"full signature: def clip_scores( scores, margin=1., hard_thresholds=None ) comments: clip +-inf values in scores +inf values in scores will be replaced by the maximum value (exclucing +inf) plus one -inf values in scores will be replaced by the minimim value (exclucing -inf) minus one input arguments: - scores: 1D numpy array - margin: margin between maximum value (excluding inf) and where to put inf. - hard_thresholds: tuple of values for -inf, +inf (in case the min or max cannot be determined) returns - array with same length as scores with elements replaced as explained above","title":"clip_scores"},{"location":"utils/clustering_utils/","text":"clustering utils A collection of functions used for performing clustering tasks This collection of tools is a little deprecated at this moment but kept for reference; it contains functionality for pre-filtering the histograms in the training set based on their moments (e.g. mean, rms). Note that the functions here have not been used in a long time and might need some maintenance before they work properly again. vecdist full signature: def vecdist(moments, index) comments: calculate the vectorial distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the points are considered as vectors and the point at index is the origin. with respect to this origin, the average vector before index and the average vector after index are calculated. the distance is then defined as the norm of the difference of these vectors, normalized by the norms of the individual vectors. costhetadist full signature: def costhetadist(moments, index) comments: calculate the costheta distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - this distance measure takes the cosine of the angle between the point at index and the one at index-1 (interpreted as vectors from the origin). avgnndist full signature: def avgnndist(moments, index, nn) comments: calculate average euclidean distance to neighbouring points input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances - nn: (half-) window size returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the average euclidean distance is calculated between the point at 'index' and the points at index-nn and index+nn (e.g. the nn previous and next lumisections). getavgnndist full signature: def getavgnndist(hists, nmoments, xmin, xmax, nbins, nneighbours) comments: apply avgnndist to a set of histograms filteranomalous full signature: def filteranomalous(df, nmoments=3, rmouterflow=True, rmlargest=0., doplot=True) comments: do a pre-filtering, removing the histograms with anomalous moments","title":"clustering_utils"},{"location":"utils/clustering_utils/#clustering-utils","text":"A collection of functions used for performing clustering tasks This collection of tools is a little deprecated at this moment but kept for reference; it contains functionality for pre-filtering the histograms in the training set based on their moments (e.g. mean, rms). Note that the functions here have not been used in a long time and might need some maintenance before they work properly again.","title":"clustering utils"},{"location":"utils/clustering_utils/#vecdist","text":"full signature: def vecdist(moments, index) comments: calculate the vectorial distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the points are considered as vectors and the point at index is the origin. with respect to this origin, the average vector before index and the average vector after index are calculated. the distance is then defined as the norm of the difference of these vectors, normalized by the norms of the individual vectors.","title":"vecdist"},{"location":"utils/clustering_utils/#costhetadist","text":"full signature: def costhetadist(moments, index) comments: calculate the costheta distance between a set of moments input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - this distance measure takes the cosine of the angle between the point at index and the one at index-1 (interpreted as vectors from the origin).","title":"costhetadist"},{"location":"utils/clustering_utils/#avgnndist","text":"full signature: def avgnndist(moments, index, nn) comments: calculate average euclidean distance to neighbouring points input arguments: - moments: 2D numpy array of shape (ninstances,nmoments) - index: index for which instance to calculate the distance relative to the other instances - nn: (half-) window size returns: - a distance measure for the given index w.r.t. the other instances in 'moments' notes: - for this distance measure, the average euclidean distance is calculated between the point at 'index' and the points at index-nn and index+nn (e.g. the nn previous and next lumisections).","title":"avgnndist"},{"location":"utils/clustering_utils/#getavgnndist","text":"full signature: def getavgnndist(hists, nmoments, xmin, xmax, nbins, nneighbours) comments: apply avgnndist to a set of histograms","title":"getavgnndist"},{"location":"utils/clustering_utils/#filteranomalous","text":"full signature: def filteranomalous(df, nmoments=3, rmouterflow=True, rmlargest=0., doplot=True) comments: do a pre-filtering, removing the histograms with anomalous moments","title":"filteranomalous"},{"location":"utils/csv_utils/","text":"csv utils A collection of useful basic functions for reading and processing the input csv files. Functionality includes: - reading the raw input csv files and producing more manageable csv files (grouped per histogram type). - reading csv files into pandas dataframes and writing pandas dataframes back to csv files. Note: the functionality of these utils has been absorbed into the DataLoader class, which is now the recommended way to read the data! get_data_dirs full signature: def get_data_dirs(year='2017', eras=[], dim=1) comments: yield all data directories note that the location of the data is hard-coded; this function might break for newer or later reprocessings of the data. - year is a string, either '2017' or '2018' - era is a list containing a selection of era names (default empty list = all eras) - dim is either 1 or 2 (for 1D or 2D plots) get_csv_files full signature: def get_csv_files(inputdir) comments: yields paths to all csv files in input directory note that the output paths consist of input_dir/filename this function is only meant for 1-level down searching, i.e. the .csv files listed directly under input_dir. sort_filenames full signature: def sort_filenames(filelist) comments: sort filenames in numerical order (e.g. 2 before 10) note that the number is supposed to be in ..._<number>.<extension> format read_csv full signature: def read_csv(csv_file) comments: read csv file into pandas dataframe csv_file is the path to the csv file to be read DEPRECATED, this function might be removed in the future; use DataLoader.get_dataframe_from_file instead. write_csv full signature: def write_csv(dataframe, csvfilename) comments: write a dataframe to a csv file note: just a wrapper for builtin dataframe.to_csv DEPRECATED, this function might be removed in the future; use DataLoader.write_dataframe_to_file instead. read_and_merge_csv full signature: def read_and_merge_csv(csv_files, histnames=[], runnbs=[]) comments: read and merge list of csv files into a single df csv_files is a list of paths to files to merge into a df histnames is a list of the types of histograms to keep (default: all) runnbs is a list of run numbers to keep (default: all) DEPRECATED, this function might be removed in the future; use DataLoader.get_dataframe_from_files instead. write_skimmed_csv full signature: def write_skimmed_csv(histnames, year, eras=['all'], dim=1) comments: read all available data for a given year/era and make a file per histogram type DEPRECATED, this function might be removed in the future; see tutorial read_and_write_data.ipynb for equivalent functionality. input arguments: - histnames: list of histogram names for which to make a separate file - year: data-taking year (in string format) - eras: data-taking eras for which to make a separate file (in string format) use 'all' to make a file with all eras merged, i.e. a full data taking year - dim: dimension of histograms (1 or 2), needed to retrieve the correct folder containing input files output: - one csv file per year/era and per histogram type note: this function can take quite a while to run!","title":"csv_utils"},{"location":"utils/csv_utils/#csv-utils","text":"A collection of useful basic functions for reading and processing the input csv files. Functionality includes: - reading the raw input csv files and producing more manageable csv files (grouped per histogram type). - reading csv files into pandas dataframes and writing pandas dataframes back to csv files. Note: the functionality of these utils has been absorbed into the DataLoader class, which is now the recommended way to read the data!","title":"csv utils"},{"location":"utils/csv_utils/#get95data95dirs","text":"full signature: def get_data_dirs(year='2017', eras=[], dim=1) comments: yield all data directories note that the location of the data is hard-coded; this function might break for newer or later reprocessings of the data. - year is a string, either '2017' or '2018' - era is a list containing a selection of era names (default empty list = all eras) - dim is either 1 or 2 (for 1D or 2D plots)","title":"get_data_dirs"},{"location":"utils/csv_utils/#get95csv95files","text":"full signature: def get_csv_files(inputdir) comments: yields paths to all csv files in input directory note that the output paths consist of input_dir/filename this function is only meant for 1-level down searching, i.e. the .csv files listed directly under input_dir.","title":"get_csv_files"},{"location":"utils/csv_utils/#sort95filenames","text":"full signature: def sort_filenames(filelist) comments: sort filenames in numerical order (e.g. 2 before 10) note that the number is supposed to be in ..._<number>.<extension> format","title":"sort_filenames"},{"location":"utils/csv_utils/#read95csv","text":"full signature: def read_csv(csv_file) comments: read csv file into pandas dataframe csv_file is the path to the csv file to be read DEPRECATED, this function might be removed in the future; use DataLoader.get_dataframe_from_file instead.","title":"read_csv"},{"location":"utils/csv_utils/#write95csv","text":"full signature: def write_csv(dataframe, csvfilename) comments: write a dataframe to a csv file note: just a wrapper for builtin dataframe.to_csv DEPRECATED, this function might be removed in the future; use DataLoader.write_dataframe_to_file instead.","title":"write_csv"},{"location":"utils/csv_utils/#read95and95merge95csv","text":"full signature: def read_and_merge_csv(csv_files, histnames=[], runnbs=[]) comments: read and merge list of csv files into a single df csv_files is a list of paths to files to merge into a df histnames is a list of the types of histograms to keep (default: all) runnbs is a list of run numbers to keep (default: all) DEPRECATED, this function might be removed in the future; use DataLoader.get_dataframe_from_files instead.","title":"read_and_merge_csv"},{"location":"utils/csv_utils/#write95skimmed95csv","text":"full signature: def write_skimmed_csv(histnames, year, eras=['all'], dim=1) comments: read all available data for a given year/era and make a file per histogram type DEPRECATED, this function might be removed in the future; see tutorial read_and_write_data.ipynb for equivalent functionality. input arguments: - histnames: list of histogram names for which to make a separate file - year: data-taking year (in string format) - eras: data-taking eras for which to make a separate file (in string format) use 'all' to make a file with all eras merged, i.e. a full data taking year - dim: dimension of histograms (1 or 2), needed to retrieve the correct folder containing input files output: - one csv file per year/era and per histogram type note: this function can take quite a while to run!","title":"write_skimmed_csv"},{"location":"utils/dataframe_utils/","text":"dataframe utils A collection of useful basic functions for manipulating pandas dataframes. Functionality includes (among others): - selecting DCS-bit on data or golden json data. - selecting specific runs, lumisections, or types of histograms get_histnames full signature: def get_histnames(df) comments: get a list of (unique) histogram names present in a df df is a dataframe read from an input csv file. select_histnames full signature: def select_histnames(df, histnames) comments: keep only a subset of histograms in a df histnames is a list of histogram names to keep in the df. get_runs full signature: def get_runs(df) comments: return a list of (unique) run numbers present in a df df is a dataframe read from an input csv file. select_runs full signature: def select_runs(df, runnbs) comments: keep only a subset of runs in a df runnbs is a list of run numbers to keep in the df. get_ls full signature: def get_ls(df) comments: return a list of ls numbers present in a df note that the numbers are not required to be unique! note: no check is done on the run number! select_ls full signature: def select_ls(df, lsnbs) comments: keep only a subset of lumisection numbers in a df lsnbs is a list of lumisection numbers to keep in the df. note: no check is done on the run number! get_runsls full signature: def get_runsls(df) comments: return a dictionary with runs and lumisections in a dataframe (same format as e.g. golden json) select_json full signature: def select_json(df, jsonfile) comments: keep only lumisections that are in the given json file select_runsls full signature: def select_runsls(df, jsondict) comments: equivalent to select_json but using a pre-loaded json dict instead of a json file on disk select_golden full signature: def select_golden(df) comments: keep only golden lumisections in df select_notgolden full signature: def select_notgolden(df) comments: keep all but golden lumisections in df select_dcson full signature: def select_dcson(df) comments: keep only lumisections in df that have DCS-bit on select_dcsoff full signature: def select_dcsoff(df) comments: keep only lumisections in df that have DCS-bit off select_pixelgood full signature: def select_pixelgood(df) comments: keep only lumisections in df that are in good pixel json select_pixelbad full signature: def select_pixelbad(df) comments: keep only lumisections in df that are in bad pixel json get_highstat full signature: def get_highstat(df, entries_to_bins_ratio=100) comments: return a select object of runs and ls of histograms with high statistics select_highstat full signature: def select_highstat(df, entries_to_bins_ratio=100) comments: keep only lumisection in df with high statistics get_hist_values full signature: def get_hist_values(df) comments: same as builtin \"df['histo'].values\" but convert strings to np arrays input arguments: - df: a dataframe containing histograms (assumed to be of a single type!) note: this function works for both 1D and 2D histograms, the distinction is made based on whether or not 'Ybins' is present as a column in the dataframe update: 'Ybins' is also present for 1D histograms, but has value 1! output: a tuple containing the following elements: - np array of shape (nhists,nbins) (for 1D) or (nhists,nybins,nxbins) (for 2D) - np array of run numbers of length nhists - np array of lumisection numbers of length nhists warning: no check is done to assure that all histograms are of the same type!","title":"dataframe_utils"},{"location":"utils/dataframe_utils/#dataframe-utils","text":"A collection of useful basic functions for manipulating pandas dataframes. Functionality includes (among others): - selecting DCS-bit on data or golden json data. - selecting specific runs, lumisections, or types of histograms","title":"dataframe utils"},{"location":"utils/dataframe_utils/#get95histnames","text":"full signature: def get_histnames(df) comments: get a list of (unique) histogram names present in a df df is a dataframe read from an input csv file.","title":"get_histnames"},{"location":"utils/dataframe_utils/#select95histnames","text":"full signature: def select_histnames(df, histnames) comments: keep only a subset of histograms in a df histnames is a list of histogram names to keep in the df.","title":"select_histnames"},{"location":"utils/dataframe_utils/#get95runs","text":"full signature: def get_runs(df) comments: return a list of (unique) run numbers present in a df df is a dataframe read from an input csv file.","title":"get_runs"},{"location":"utils/dataframe_utils/#select95runs","text":"full signature: def select_runs(df, runnbs) comments: keep only a subset of runs in a df runnbs is a list of run numbers to keep in the df.","title":"select_runs"},{"location":"utils/dataframe_utils/#get95ls","text":"full signature: def get_ls(df) comments: return a list of ls numbers present in a df note that the numbers are not required to be unique! note: no check is done on the run number!","title":"get_ls"},{"location":"utils/dataframe_utils/#select95ls","text":"full signature: def select_ls(df, lsnbs) comments: keep only a subset of lumisection numbers in a df lsnbs is a list of lumisection numbers to keep in the df. note: no check is done on the run number!","title":"select_ls"},{"location":"utils/dataframe_utils/#get95runsls","text":"full signature: def get_runsls(df) comments: return a dictionary with runs and lumisections in a dataframe (same format as e.g. golden json)","title":"get_runsls"},{"location":"utils/dataframe_utils/#select95json","text":"full signature: def select_json(df, jsonfile) comments: keep only lumisections that are in the given json file","title":"select_json"},{"location":"utils/dataframe_utils/#select95runsls","text":"full signature: def select_runsls(df, jsondict) comments: equivalent to select_json but using a pre-loaded json dict instead of a json file on disk","title":"select_runsls"},{"location":"utils/dataframe_utils/#select95golden","text":"full signature: def select_golden(df) comments: keep only golden lumisections in df","title":"select_golden"},{"location":"utils/dataframe_utils/#select95notgolden","text":"full signature: def select_notgolden(df) comments: keep all but golden lumisections in df","title":"select_notgolden"},{"location":"utils/dataframe_utils/#select95dcson","text":"full signature: def select_dcson(df) comments: keep only lumisections in df that have DCS-bit on","title":"select_dcson"},{"location":"utils/dataframe_utils/#select95dcsoff","text":"full signature: def select_dcsoff(df) comments: keep only lumisections in df that have DCS-bit off","title":"select_dcsoff"},{"location":"utils/dataframe_utils/#select95pixelgood","text":"full signature: def select_pixelgood(df) comments: keep only lumisections in df that are in good pixel json","title":"select_pixelgood"},{"location":"utils/dataframe_utils/#select95pixelbad","text":"full signature: def select_pixelbad(df) comments: keep only lumisections in df that are in bad pixel json","title":"select_pixelbad"},{"location":"utils/dataframe_utils/#get95highstat","text":"full signature: def get_highstat(df, entries_to_bins_ratio=100) comments: return a select object of runs and ls of histograms with high statistics","title":"get_highstat"},{"location":"utils/dataframe_utils/#select95highstat","text":"full signature: def select_highstat(df, entries_to_bins_ratio=100) comments: keep only lumisection in df with high statistics","title":"select_highstat"},{"location":"utils/dataframe_utils/#get95hist95values","text":"full signature: def get_hist_values(df) comments: same as builtin \"df['histo'].values\" but convert strings to np arrays input arguments: - df: a dataframe containing histograms (assumed to be of a single type!) note: this function works for both 1D and 2D histograms, the distinction is made based on whether or not 'Ybins' is present as a column in the dataframe update: 'Ybins' is also present for 1D histograms, but has value 1! output: a tuple containing the following elements: - np array of shape (nhists,nbins) (for 1D) or (nhists,nybins,nxbins) (for 2D) - np array of run numbers of length nhists - np array of lumisection numbers of length nhists warning: no check is done to assure that all histograms are of the same type!","title":"get_hist_values"},{"location":"utils/generate_data_2d_utils/","text":"generate data 2d utils Extension of generate_data_utils.py towards 2D histograms goodnoise_nd full signature: def goodnoise_nd(shape, fstd=None, kmaxscale=0.25, ncomponents=3) comments: generate one sample of 'good' noise consisting of fourier components generalization of goodnoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). - kmaxscale: scale factor to limit maximum frequency (lower kmaxscale means smoother noise) note: can be a tuple with same length as shape, to scale differently in different dimensions. - ncomponents: number of random sines to add per dimension note: can be a tuple with same length as shape, to use a different number of components in different dimensions. output: - numpy array of shape detailed by shape argument containing the noise whitenoise_nd full signature: def whitenoise_nd(shape, fstd=None) comments: generate one sample of white noise (standard normally distributed, uncorrelated between bins) generalization of whitenoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). output: - numpy array of shape detailed by shape argument containing the noise random_lico_nd full signature: def random_lico_nd(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1. generalization of random_lico (see generate_data_utils) to arbitrary number of dimensions. input args: - numpy array of shape (nhists,<arbitrary number of additional dimensions>) output: - numpy array of shape (<same dimensions as input>), containing the new histogram fourier_noise_nd full signature: def fourier_noise_nd(hists, outfilename=None, doplot=False, ntarget=None, nresamples=1, nonnegative=True, stdfactor=15., kmaxscale=0.25, ncomponents=3) comments: apply fourier noise on random histograms with simple flat amplitude scaling. generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - outfilename: path to csv file to write results to (default: no writing) - doplot: boolean whether to make a plot of some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: use nresamples instead) - nresamples: number of samples to draw per input histogram (note: ignored if ntarget is not None) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - kmaxscale and ncomponents: see goodnoise_nd white_noise_nd full signature: def white_noise_nd(hists, doplot=False, ntarget=None, nresamples=1, nonnegative=True, stdfactor=15.) comments: apply white noise to the histograms in hists. generalization of white_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: np array (nhists,<arbitrary number of dimensions>) containing input histograms - doplot: boolean whether to plot some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: use nresamples instead) - nresamples: number of samples to draw per input histogram (note: ignored if ntarget is not None) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise) resample_lico_nd full signature: def resample_lico_nd(hists, doplot=False, ntarget=None, nonnegative=True) comments: take random linear combinations of input histograms generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - doplot: boolean whether to plot some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: same as number of input histograms) - nonnegative: boolean whether to set all bins to minimum zero after applying noise note: coefficients in linear combination are always nonnegative, so this setting is superfluous is input histograms are all nonnegative","title":"generate_data_2d_utils"},{"location":"utils/generate_data_2d_utils/#generate-data-2d-utils","text":"Extension of generate_data_utils.py towards 2D histograms","title":"generate data 2d utils"},{"location":"utils/generate_data_2d_utils/#goodnoise95nd","text":"full signature: def goodnoise_nd(shape, fstd=None, kmaxscale=0.25, ncomponents=3) comments: generate one sample of 'good' noise consisting of fourier components generalization of goodnoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). - kmaxscale: scale factor to limit maximum frequency (lower kmaxscale means smoother noise) note: can be a tuple with same length as shape, to scale differently in different dimensions. - ncomponents: number of random sines to add per dimension note: can be a tuple with same length as shape, to use a different number of components in different dimensions. output: - numpy array of shape detailed by shape argument containing the noise","title":"goodnoise_nd"},{"location":"utils/generate_data_2d_utils/#whitenoise95nd","text":"full signature: def whitenoise_nd(shape, fstd=None) comments: generate one sample of white noise (standard normally distributed, uncorrelated between bins) generalization of whitenoise (see generate_data_utils) to arbitrary number of dimensions input args: - shape: a tuple, shape of the noise array to be sampled note: in case of 1D, a comma is needed e.g. shape = (30,) else it will be automatically parsed to int and raise an error - fstd: an array of shape given by shape argument, used for scaling of the amplitude of the noise bin-by-bin (default: no scaling). output: - numpy array of shape detailed by shape argument containing the noise","title":"whitenoise_nd"},{"location":"utils/generate_data_2d_utils/#random95lico95nd","text":"full signature: def random_lico_nd(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1. generalization of random_lico (see generate_data_utils) to arbitrary number of dimensions. input args: - numpy array of shape (nhists,<arbitrary number of additional dimensions>) output: - numpy array of shape (<same dimensions as input>), containing the new histogram","title":"random_lico_nd"},{"location":"utils/generate_data_2d_utils/#fourier95noise95nd","text":"full signature: def fourier_noise_nd(hists, outfilename=None, doplot=False, ntarget=None, nresamples=1, nonnegative=True, stdfactor=15., kmaxscale=0.25, ncomponents=3) comments: apply fourier noise on random histograms with simple flat amplitude scaling. generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - outfilename: path to csv file to write results to (default: no writing) - doplot: boolean whether to make a plot of some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: use nresamples instead) - nresamples: number of samples to draw per input histogram (note: ignored if ntarget is not None) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - kmaxscale and ncomponents: see goodnoise_nd","title":"fourier_noise_nd"},{"location":"utils/generate_data_2d_utils/#white95noise95nd","text":"full signature: def white_noise_nd(hists, doplot=False, ntarget=None, nresamples=1, nonnegative=True, stdfactor=15.) comments: apply white noise to the histograms in hists. generalization of white_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: np array (nhists,<arbitrary number of dimensions>) containing input histograms - doplot: boolean whether to plot some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: use nresamples instead) - nresamples: number of samples to draw per input histogram (note: ignored if ntarget is not None) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise)","title":"white_noise_nd"},{"location":"utils/generate_data_2d_utils/#resample95lico95nd","text":"full signature: def resample_lico_nd(hists, doplot=False, ntarget=None, nonnegative=True) comments: take random linear combinations of input histograms generalization of fourier_noise (see generate_data_utils) to arbitrary number of dimensions. input args: - hists: numpy array of shape (nhists,<arbitrary number of dimensions>) used for seeding - doplot: boolean whether to plot some examples (only for 2D histograms!) - ntarget: total target number of histograms (default: same as number of input histograms) - nonnegative: boolean whether to set all bins to minimum zero after applying noise note: coefficients in linear combination are always nonnegative, so this setting is superfluous is input histograms are all nonnegative","title":"resample_lico_nd"},{"location":"utils/generate_data_utils/","text":"generate data utils A collection of functions for artificially creating a labeled dataset. See the function documentation below for more details on the implemented methods. Also check the tutorial generate_data.ipynb for examples! goodnoise full signature: def goodnoise(nbins, fstd=None) comments: generate one sample of 'good' noise consisting of fourier components input args: - nbins: number of bins, length of noise array to be sampled - fstd: an array of length nbins used for scaling of the amplitude of the noise bin-by-bin. output: - numpy array of length nbins containing the noise badnoise full signature: def badnoise(nbins, fstd=None) comments: generate one sample of 'bad' noise consisting of fourier components (higher frequency and amplitude than 'good' noise) input args and output: simlar to goodnoise WARNING: NOT NECESSARILY REPRESENTATIVE OF ANOMALIES TO BE EXPECTED, DO NOT USE whitenoise full signature: def whitenoise(nbins, fstd=None) comments: generate one sample of white noise (uncorrelated between bins) input args and output: similar to goodnoise random_lico full signature: def random_lico(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1 input args: - numpy array of shape (nhists,nbins), the rows of which will be linearly combined output: - numpy array of shape (nbins), containing the new histogram smoother full signature: def smoother(inarray, halfwidth=1) comments: smooth the rows of a 2D array using the 2*halfwidth+1 surrounding values. mse_correlation_vector full signature: def mse_correlation_vector(hists, index) comments: calculate mse of a histogram at given index wrt all other histograms input args: - hists: numpy array of shape (nhists,nbins) containing the histograms - index: the index (must be in (0,len(hists)-1)) of the histogram in question output: - numpy array of length nhists containing mse of the indexed histogram with respect to all other histograms WARNING: can be slow if called many times on a large collection of histograms with many bins. moments_correlation_vector full signature: def moments_correlation_vector(moments, index) comments: calculate moment distance of hist at index wrt all other hists very similar to mse_correlation_vector but using histogram moments instead of full histograms for speed-up plot_data_and_gen full signature: def plot_data_and_gen(datahists, genhists, fig=None, axs=None, datacolor='b', gencolor='b', datalabel='Histograms from data', genlabel='Artificially generated histograms') comments: plot a couple of random examples from data and generated histograms note: both are plotted in different subplots of the same figure input arguments: - datahists, genhists: numpy arrays of shape (nhists,nbins) - fig, axs: a matplotlib figure object and a list of two axes objects (if either is None, a new figure with two subplots will be created) plot_seed_and_gen full signature: def plot_seed_and_gen(seedhists, genhists, fig=None, ax=None, seedcolor='b', gencolor='g', seedlabel='Histograms from data', genlabel='Artificially generated histograms') comments: plot seed and generated histograms note: both are plotted in the same subplot input arguments: - seedhists, genhists: numpy arrays of shape (nhists,nbins) - fig, ax: a matplotlib figure object and an axes object (if either is None, a new figure will be created) plot_noise full signature: def plot_noise(noise, fig=None, ax=None, noiselabel='Examples of noise', noisecolor='b', histstd=None, histstdlabel='Variation') comments: plot histograms in noise (numpy array of shape (nhists,nbins)) input arguments: - noise: 2D numpy array of shape (nexamples,nbins) - fig, ax: a matplotlib figure object and an axes object (if either is None, a new figure will be created) - noiselabel: label for noise examples (use None to not add a legend entry for noise) - noisecolor: color for noise examples on plot - histstd: 1D numpy array of shape (nbins) displaying some order-of-magnitude allowed variation (typically some measure of per-bin variation in the input histogram(s)) - histstdlabel: label for histstd (use None to not add a legend entry for histstd) fourier_noise_on_mean full signature: def fourier_noise_on_mean(hists, outfilename='', nresamples=0, nonnegative=True, doplot=True) comments: apply fourier noise on the bin-per-bin mean histogram, with amplitude scaling based on bin-per-bin std histogram. input args: - hists: numpy array of shape (nhists,nbins) used for determining mean and std - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw (default: number of input histograms / 10) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False MOSTLY SUITABLE AS HELP FUNCTION FOR RESAMPLE_SIMILAR_FOURIER_NOISE, NOT AS GENERATOR IN ITSELF advantages: mean histogram is almost certainly 'good' because of averaging, eliminate bad histograms disadvantages: deviations from mean are small, does not model systematic shifts by lumi. fourier_noise full signature: def fourier_noise(hists, outfilename='', nresamples=1, nonnegative=True, stdfactor=15., doplot=True) comments: apply fourier noise on random histograms with simple flat amplitude scaling. input args: - hists: numpy array of shape (nhists,nbins) used for seeding - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: resampled histograms will have statistically same features as original input set disadvantages: also 'bad' histograms will be resampled if included in hists upsample_hist_set full signature: def upsample_hist_set(hists, ntarget=-1, fourierstdfactor=15., doplot=True) comments: wrapper for fourier_noise allowing for a fixed target number of histograms instead of a fixed resampling factor. useful function for quickly generating a fixed number of resampled histograms, without bothering too much about what exact resampling technique or detailed settings would be most appropriate. input arguments: - hists: input histogram set - ntarget: targetted number of resampled histograms (default: equally many as in hists) - fourierstdfactor: see fourier_noise - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False white_noise full signature: def white_noise(hists, stdfactor=15., doplot=True) comments: apply white noise to the histograms in hists. input args: - hists: np array (nhists,nbins) containing input histograms - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False resample_bin_per_bin full signature: def resample_bin_per_bin(hists, outfilename='', nresamples=0, nonnegative=True, smoothinghalfwidth=2, doplot=True) comments: do resampling from bin-per-bin probability distributions input args: - hists: np array (nhists,nbins) containing the histograms to draw new samples from - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw (default: 1/10 of number of input histograms) - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - smoothinghalfwidth: halfwidth of smoothing procedure to apply on the result (default: no smoothing) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no arbitrary noise modeling disadvantages: bins are considered independent, shape of historams not taken into account, does not work well on small number of input histograms, does not work well on histograms with systematic shifts resample_similar_bin_per_bin full signature: def resample_similar_bin_per_bin( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: resample from bin-per-bin probability distributions, but only from similar looking histograms. input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no assumptions on shape of noise, can handle systematic shifts in histograms disadvantages: bins are treated independently from each other resample_similar_fourier_noise full signature: def resample_similar_fourier_noise( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: apply fourier noise on mean histogram, where the mean is determined from a set of similar-looking histograms input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: most of fourier_noise_on_mean but can additionally handle shifting histograms, apart from fourier noise, also white noise can be applied. disadvantages: does not filter out odd histograms as long as enough other odd histograms look more or less similar resample_similar_lico full signature: def resample_similar_lico( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: take linear combinations of similar histograms input arguments: - allhists: 2D np array (nhists,nbins) with all available histograms, used to take linear combinations - selhists: 2D np array (nhists,nbins) with selected hists used for seeding (e.g. 'good' histograms) - outfilename: path to csv file to write result to (default: no writing) - nresamples: number of combinations to make per input histogram - nonnegative: boolean whether to make all final histograms nonnegative - keeppercentage: percentage (between 0. and 100.) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no assumptions on noise disadvantages: sensitive to outlying histograms (more than with averaging) mc_sampling full signature: def mc_sampling(hists, nMC=10000 , nresamples=10, doplot=True) comments: resampling of a histogram using MC methods Drawing random points from a space defined by the range of the histogram in all axes. Points are \"accepted\" if the fall under the sampled histogram: f(x) - sampled distribution x_r, y_r -> randomly sampled point if y_r<=f(x_r), fill the new distribution at bin corresponding to x_r with weight: weight = (sum of input hist)/(#mc points accepted) this is equal to weight = (MC space volume)/(all MC points)","title":"generate_data_utils"},{"location":"utils/generate_data_utils/#generate-data-utils","text":"A collection of functions for artificially creating a labeled dataset. See the function documentation below for more details on the implemented methods. Also check the tutorial generate_data.ipynb for examples!","title":"generate data utils"},{"location":"utils/generate_data_utils/#goodnoise","text":"full signature: def goodnoise(nbins, fstd=None) comments: generate one sample of 'good' noise consisting of fourier components input args: - nbins: number of bins, length of noise array to be sampled - fstd: an array of length nbins used for scaling of the amplitude of the noise bin-by-bin. output: - numpy array of length nbins containing the noise","title":"goodnoise"},{"location":"utils/generate_data_utils/#badnoise","text":"full signature: def badnoise(nbins, fstd=None) comments: generate one sample of 'bad' noise consisting of fourier components (higher frequency and amplitude than 'good' noise) input args and output: simlar to goodnoise WARNING: NOT NECESSARILY REPRESENTATIVE OF ANOMALIES TO BE EXPECTED, DO NOT USE","title":"badnoise"},{"location":"utils/generate_data_utils/#whitenoise","text":"full signature: def whitenoise(nbins, fstd=None) comments: generate one sample of white noise (uncorrelated between bins) input args and output: similar to goodnoise","title":"whitenoise"},{"location":"utils/generate_data_utils/#random95lico","text":"full signature: def random_lico(hists) comments: generate one linear combination of histograms with random coefficients in (0,1) summing to 1 input args: - numpy array of shape (nhists,nbins), the rows of which will be linearly combined output: - numpy array of shape (nbins), containing the new histogram","title":"random_lico"},{"location":"utils/generate_data_utils/#smoother","text":"full signature: def smoother(inarray, halfwidth=1) comments: smooth the rows of a 2D array using the 2*halfwidth+1 surrounding values.","title":"smoother"},{"location":"utils/generate_data_utils/#mse95correlation95vector","text":"full signature: def mse_correlation_vector(hists, index) comments: calculate mse of a histogram at given index wrt all other histograms input args: - hists: numpy array of shape (nhists,nbins) containing the histograms - index: the index (must be in (0,len(hists)-1)) of the histogram in question output: - numpy array of length nhists containing mse of the indexed histogram with respect to all other histograms WARNING: can be slow if called many times on a large collection of histograms with many bins.","title":"mse_correlation_vector"},{"location":"utils/generate_data_utils/#moments95correlation95vector","text":"full signature: def moments_correlation_vector(moments, index) comments: calculate moment distance of hist at index wrt all other hists very similar to mse_correlation_vector but using histogram moments instead of full histograms for speed-up","title":"moments_correlation_vector"},{"location":"utils/generate_data_utils/#plot95data95and95gen","text":"full signature: def plot_data_and_gen(datahists, genhists, fig=None, axs=None, datacolor='b', gencolor='b', datalabel='Histograms from data', genlabel='Artificially generated histograms') comments: plot a couple of random examples from data and generated histograms note: both are plotted in different subplots of the same figure input arguments: - datahists, genhists: numpy arrays of shape (nhists,nbins) - fig, axs: a matplotlib figure object and a list of two axes objects (if either is None, a new figure with two subplots will be created)","title":"plot_data_and_gen"},{"location":"utils/generate_data_utils/#plot95seed95and95gen","text":"full signature: def plot_seed_and_gen(seedhists, genhists, fig=None, ax=None, seedcolor='b', gencolor='g', seedlabel='Histograms from data', genlabel='Artificially generated histograms') comments: plot seed and generated histograms note: both are plotted in the same subplot input arguments: - seedhists, genhists: numpy arrays of shape (nhists,nbins) - fig, ax: a matplotlib figure object and an axes object (if either is None, a new figure will be created)","title":"plot_seed_and_gen"},{"location":"utils/generate_data_utils/#plot95noise","text":"full signature: def plot_noise(noise, fig=None, ax=None, noiselabel='Examples of noise', noisecolor='b', histstd=None, histstdlabel='Variation') comments: plot histograms in noise (numpy array of shape (nhists,nbins)) input arguments: - noise: 2D numpy array of shape (nexamples,nbins) - fig, ax: a matplotlib figure object and an axes object (if either is None, a new figure will be created) - noiselabel: label for noise examples (use None to not add a legend entry for noise) - noisecolor: color for noise examples on plot - histstd: 1D numpy array of shape (nbins) displaying some order-of-magnitude allowed variation (typically some measure of per-bin variation in the input histogram(s)) - histstdlabel: label for histstd (use None to not add a legend entry for histstd)","title":"plot_noise"},{"location":"utils/generate_data_utils/#fourier95noise95on95mean","text":"full signature: def fourier_noise_on_mean(hists, outfilename='', nresamples=0, nonnegative=True, doplot=True) comments: apply fourier noise on the bin-per-bin mean histogram, with amplitude scaling based on bin-per-bin std histogram. input args: - hists: numpy array of shape (nhists,nbins) used for determining mean and std - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw (default: number of input histograms / 10) - nonnegative: boolean whether to set all bins to minimum zero after applying noise - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False MOSTLY SUITABLE AS HELP FUNCTION FOR RESAMPLE_SIMILAR_FOURIER_NOISE, NOT AS GENERATOR IN ITSELF advantages: mean histogram is almost certainly 'good' because of averaging, eliminate bad histograms disadvantages: deviations from mean are small, does not model systematic shifts by lumi.","title":"fourier_noise_on_mean"},{"location":"utils/generate_data_utils/#fourier95noise","text":"full signature: def fourier_noise(hists, outfilename='', nresamples=1, nonnegative=True, stdfactor=15., doplot=True) comments: apply fourier noise on random histograms with simple flat amplitude scaling. input args: - hists: numpy array of shape (nhists,nbins) used for seeding - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw per input histogram - nonnegative: boolean whether to set all bins to minimum zero after applying noise - stdfactor: factor to scale magnitude of noise (larger factor = smaller noise) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: resampled histograms will have statistically same features as original input set disadvantages: also 'bad' histograms will be resampled if included in hists","title":"fourier_noise"},{"location":"utils/generate_data_utils/#upsample95hist95set","text":"full signature: def upsample_hist_set(hists, ntarget=-1, fourierstdfactor=15., doplot=True) comments: wrapper for fourier_noise allowing for a fixed target number of histograms instead of a fixed resampling factor. useful function for quickly generating a fixed number of resampled histograms, without bothering too much about what exact resampling technique or detailed settings would be most appropriate. input arguments: - hists: input histogram set - ntarget: targetted number of resampled histograms (default: equally many as in hists) - fourierstdfactor: see fourier_noise - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False","title":"upsample_hist_set"},{"location":"utils/generate_data_utils/#white95noise","text":"full signature: def white_noise(hists, stdfactor=15., doplot=True) comments: apply white noise to the histograms in hists. input args: - hists: np array (nhists,nbins) containing input histograms - stdfactor: scaling factor of white noise amplitude (higher factor = smaller noise) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False","title":"white_noise"},{"location":"utils/generate_data_utils/#resample95bin95per95bin","text":"full signature: def resample_bin_per_bin(hists, outfilename='', nresamples=0, nonnegative=True, smoothinghalfwidth=2, doplot=True) comments: do resampling from bin-per-bin probability distributions input args: - hists: np array (nhists,nbins) containing the histograms to draw new samples from - outfilename: path to csv file to write results to (default: no writing) - nresamples: number of samples to draw (default: 1/10 of number of input histograms) - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - smoothinghalfwidth: halfwidth of smoothing procedure to apply on the result (default: no smoothing) - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no arbitrary noise modeling disadvantages: bins are considered independent, shape of historams not taken into account, does not work well on small number of input histograms, does not work well on histograms with systematic shifts","title":"resample_bin_per_bin"},{"location":"utils/generate_data_utils/#resample95similar95bin95per95bin","text":"full signature: def resample_similar_bin_per_bin( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: resample from bin-per-bin probability distributions, but only from similar looking histograms. input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no assumptions on shape of noise, can handle systematic shifts in histograms disadvantages: bins are treated independently from each other","title":"resample_similar_bin_per_bin"},{"location":"utils/generate_data_utils/#resample95similar95fourier95noise","text":"full signature: def resample_similar_fourier_noise( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: apply fourier noise on mean histogram, where the mean is determined from a set of similar-looking histograms input args: - allhists: np array (nhists,nbins) containing all available histograms (to determine mean) - selhists: np array (nhists,nbins) conataining selected histograms used as seeds (e.g. 'good' histograms) - outfilename: path of csv file to write results to (default: no writing) - nresamples: number of samples per input histogram in selhists - nonnegative: boolean whether or not to put all bins to minimum zero after applying noise - keeppercentage: percentage (between 1 and 100) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: most of fourier_noise_on_mean but can additionally handle shifting histograms, apart from fourier noise, also white noise can be applied. disadvantages: does not filter out odd histograms as long as enough other odd histograms look more or less similar","title":"resample_similar_fourier_noise"},{"location":"utils/generate_data_utils/#resample95similar95lico","text":"full signature: def resample_similar_lico( allhists, selhists, outfilename='', nresamples=1, nonnegative=True, keeppercentage=1., doplot=True) comments: take linear combinations of similar histograms input arguments: - allhists: 2D np array (nhists,nbins) with all available histograms, used to take linear combinations - selhists: 2D np array (nhists,nbins) with selected hists used for seeding (e.g. 'good' histograms) - outfilename: path to csv file to write result to (default: no writing) - nresamples: number of combinations to make per input histogram - nonnegative: boolean whether to make all final histograms nonnegative - keeppercentage: percentage (between 0. and 100.) of histograms in allhists to use per input histogram - doplot: boolean whether to make a plot returns: a tuple of the form (resulting histograms, maplotlib figure, matplotlib axes), figure and axes are None if doplot was set to False advantages: no assumptions on noise disadvantages: sensitive to outlying histograms (more than with averaging)","title":"resample_similar_lico"},{"location":"utils/generate_data_utils/#mc95sampling","text":"full signature: def mc_sampling(hists, nMC=10000 , nresamples=10, doplot=True) comments: resampling of a histogram using MC methods Drawing random points from a space defined by the range of the histogram in all axes. Points are \"accepted\" if the fall under the sampled histogram: f(x) - sampled distribution x_r, y_r -> randomly sampled point if y_r<=f(x_r), fill the new distribution at bin corresponding to x_r with weight: weight = (sum of input hist)/(#mc points accepted) this is equal to weight = (MC space volume)/(all MC points)","title":"mc_sampling"},{"location":"utils/hist_utils/","text":"hist utils A collection of useful basic functions for processing histograms. Functionality includes: - rebinning, cropping and normalization - moment calculation - averaging over neighbouring histograms - smoothing over neighbouring bins - higher-level functions preparing data for ML training, starting from a dataframe or input csv file. crophists full signature: def crophists(hists, slices=None) comments: perform cropping on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - slices: a slice object (builtin python type) or a list of two slices (for 2D) notes: - a slice can be created using the builtin python syntax 'slice(start,stop,step)', and the syntax 'list[slice]' is equivalent to 'list[start:stop:step]'. use 'None' to ignore one of the arguments for slice creation (equivalent to ':' in direct slicing) - for 1D histograms, slices can be either a slice object or a list of length 1 containing a single slice. example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but cropped according to the slices argument get_cropslices_from_str full signature: def get_cropslices_from_str(slicestr) comments: get a collection of slices from a string (e.g. argument in gui) note: the resulting slices are typically passed to crophists (see above) input arguments: - slicestr: string representation of slices e.g. '0:6:2' for slice(0,6,2) e.g. '0:6:2,1:5:2' for [slice(0,6,2),slice(1,5,2)] rebinhists full signature: def rebinhists(hists, factor=None) comments: perform rebinning on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - factor: the rebinning factor (for 1D), or a tuple of (y axis rebinning factor, x axis rebinning factor) (for 2D) note: the rebinning applied here is simple summing of bin contents, and the rebinning factors must be divisors of the respective number of bins! example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but rebinned according to the factor argument get_rebinningfactor_from_str full signature: def get_rebinningfactor_from_str(factstr) comments: get a valid rebinning factor (int or tuple) from a string (e.g. argument in gui) note: the resulting factor is typically passed to rebinhists (see above) input arguments: - factstr: string representation of rebinning factor e.g. '4' for 4 (for 1D histograms) e.g. '4,4' for (4,4) (for 2D histograms) normalizehists full signature: def normalizehists(hists) comments: perform normalization on a set of histograms note: - for 1D histograms, the sum of bin contents is set equal one for each histogram - for 2D histograms, the bin contents are scaled so the maximum is 1 for each histogram - maybe later make more flexible by adding normalization stragy as argument... input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D returns: - a numpy array containing the same histograms as input but normalized averagehists full signature: def averagehists(hists, nout=None) comments: partition a set of histograms into equal parts and take the average histogram of each part input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - nout: number of partitions, i.e. number of output histograms note: nout=1 corresponds to simply taking the average of all histograms in hists. note: if nout is negative or if nout is larger than number of input histograms, the original set of histograms is returned. returns: - a numpy array of shape (nout,nbins) running_average_hists full signature: def running_average_hists(hists, window=None, weights=None) comments: replace each histogram in a collection of histograms by its running average input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - window: number of histograms to consider for the averaging if window is an integer, it is the number of previous histograms in hists used for averaging (so window=0 would correspond to no averaging) if window is a tuple, it corresponds to (nprevious,nnext), and the nprevious previous and nnext next histograms in hists are used for averaging (so window=(0,0) would correspond to no averaging) - weights: a list or numpy array containing the relative weights of the histograms in the averaging procedure. note: the weights can be any number, but they will be normalized to have unit sum. note: weights must have length nwindow+1 or nprevious+1+nnext. note: the default behaviour is a uniform array with values 1./(window+1) (or 1./(nprevious+1+nnext)) returns: - a numpy array with same shape as input but where each histogram is replaced by its running average notes: - at the edges, the weights are cropped to match the input array and renormalized - this function will throw an error when the length of the set of histograms is smaller than the total window length, maybe extend later (although this is not normally needed) select_random full signature: def select_random(hists, nselect=10) comments: select nselect random examples from a set of histograms input arguments: - hists: a numpy array of shape (nhistograms, nbins) for 1D or (nhistograms, nybins, nxbins) for 2D. - nselect: number of random instances to draw smoothhists full signature: def smoothhists(hists, halfwindow=None, weights=None) comments: perform histogram smoothing by averaging over neighbouring bins input arguments: - hists: a numpy array of shape (nhistograms, nbins) for 1D or (nhistograms, nybins, nxbins) for 2D. - halfwindow: number of bins to consider for the averaging; for 1D histograms, must be an int, corresponding to the number of bins before and after the current bin to average over; for 2D histograms, must be a tuple of (halfwindow_y, halfwindow_x). - weights: numpy array containing the relative weights of the bins for the averaging; for 1D histograms, must have length 2*halfwindow+1; for 2D histograms, must have shape (2*halfwindow_y+1, 2*halfwindow_x+1). note: the weights can be any number, but they will be normalized to have unit sum. note: the default behaviour is a uniform array returns: - a numpy array with same shape as input but where each histogram is replaced by its smoothed version get_smoothinghalfwindow_from_str full signature: def get_smoothinghalfwindow_from_str(windowstr) comments: get a valid smoothing half window (int or tuple) from a string (e.g. argument in gui) note: the resulting factor is typically passed to smoothhists (see above) input arguments: - windowstr: string representation of smoothing window e.g. '4' for 4 (for 1D histograms) e.g. '4,4' for (4,4) (for 2D histograms) moment full signature: def moment(bins, counts, order) comments: get n-th central moment of a histogram input arguments: - bins: a 1D or 2D np array holding the bin centers (shape (nbins) or (nhistograms,nbins)) - counts: a 2D np array containing the bin counts (shape (nhistograms,nbins)) - order: the order of the moment to calculate (0 = maximum value, 1 = mean value) returns: - an array of shape (nhistograms) holding the requested moment per histogram notes: - for now only 1D histograms are supported! histmean full signature: def histmean(bins, counts) comments: special case of moment calculation (with order=1) histrms full signature: def histrms(bins, counts) comments: special case of moment calculation histmoments full signature: def histmoments(bins, counts, orders) comments: apply moment calculation for a list of orders input arguments: - see function moment(bins, counts, order), the only difference being that orders is a list instead of a single number returns: - a numpy array of shape (nhistograms,nmoments) preparedatafromnpy full signature: def preparedatafromnpy(dataname, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True, doplot=False) comments: read a .npy file and output the histograms input arguments: - see e.g. preparedatafromdf notes: - not yet tested for 2D histograms, but is expected to work... preparedatafromdf full signature: def preparedatafromdf(df, returnrunls=False, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=False, doplot=False) comments: prepare the data contained in a dataframe in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - smoothinghalfwindow: int or tuple (for 1D/2D histograms) used for smoothing the histograms - smoothingweights: 1D or 2D array (for 1D/2D histograms) with weights for smoothing - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms preparedatafromcsv full signature: def preparedatafromcsv(dataname, returnrunls=False, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True, doplot=False) comments: prepare the data contained in a dataframe csv file in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - smoothinghalfwindow: int or tuple (for 1D/2D histograms) used for smoothing the histograms - smoothingweights: 1D or 2D array (for 1D/2D histograms) with weights for smoothing - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"hist_utils"},{"location":"utils/hist_utils/#hist-utils","text":"A collection of useful basic functions for processing histograms. Functionality includes: - rebinning, cropping and normalization - moment calculation - averaging over neighbouring histograms - smoothing over neighbouring bins - higher-level functions preparing data for ML training, starting from a dataframe or input csv file.","title":"hist utils"},{"location":"utils/hist_utils/#crophists","text":"full signature: def crophists(hists, slices=None) comments: perform cropping on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - slices: a slice object (builtin python type) or a list of two slices (for 2D) notes: - a slice can be created using the builtin python syntax 'slice(start,stop,step)', and the syntax 'list[slice]' is equivalent to 'list[start:stop:step]'. use 'None' to ignore one of the arguments for slice creation (equivalent to ':' in direct slicing) - for 1D histograms, slices can be either a slice object or a list of length 1 containing a single slice. example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but cropped according to the slices argument","title":"crophists"},{"location":"utils/hist_utils/#get95cropslices95from95str","text":"full signature: def get_cropslices_from_str(slicestr) comments: get a collection of slices from a string (e.g. argument in gui) note: the resulting slices are typically passed to crophists (see above) input arguments: - slicestr: string representation of slices e.g. '0:6:2' for slice(0,6,2) e.g. '0:6:2,1:5:2' for [slice(0,6,2),slice(1,5,2)]","title":"get_cropslices_from_str"},{"location":"utils/hist_utils/#rebinhists","text":"full signature: def rebinhists(hists, factor=None) comments: perform rebinning on a set of histograms input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - factor: the rebinning factor (for 1D), or a tuple of (y axis rebinning factor, x axis rebinning factor) (for 2D) note: the rebinning applied here is simple summing of bin contents, and the rebinning factors must be divisors of the respective number of bins! example usage: - see tutorials/plot_histograms_2d.ipynb returns: - a numpy array containing the same histograms as input but rebinned according to the factor argument","title":"rebinhists"},{"location":"utils/hist_utils/#get95rebinningfactor95from95str","text":"full signature: def get_rebinningfactor_from_str(factstr) comments: get a valid rebinning factor (int or tuple) from a string (e.g. argument in gui) note: the resulting factor is typically passed to rebinhists (see above) input arguments: - factstr: string representation of rebinning factor e.g. '4' for 4 (for 1D histograms) e.g. '4,4' for (4,4) (for 2D histograms)","title":"get_rebinningfactor_from_str"},{"location":"utils/hist_utils/#normalizehists","text":"full signature: def normalizehists(hists) comments: perform normalization on a set of histograms note: - for 1D histograms, the sum of bin contents is set equal one for each histogram - for 2D histograms, the bin contents are scaled so the maximum is 1 for each histogram - maybe later make more flexible by adding normalization stragy as argument... input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D returns: - a numpy array containing the same histograms as input but normalized","title":"normalizehists"},{"location":"utils/hist_utils/#averagehists","text":"full signature: def averagehists(hists, nout=None) comments: partition a set of histograms into equal parts and take the average histogram of each part input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - nout: number of partitions, i.e. number of output histograms note: nout=1 corresponds to simply taking the average of all histograms in hists. note: if nout is negative or if nout is larger than number of input histograms, the original set of histograms is returned. returns: - a numpy array of shape (nout,nbins)","title":"averagehists"},{"location":"utils/hist_utils/#running95average95hists","text":"full signature: def running_average_hists(hists, window=None, weights=None) comments: replace each histogram in a collection of histograms by its running average input arguments: - hists: a numpy array of shape (nhistograms,nbins) for 1D or (nhistograms,nybins,nxbins) for 2D - window: number of histograms to consider for the averaging if window is an integer, it is the number of previous histograms in hists used for averaging (so window=0 would correspond to no averaging) if window is a tuple, it corresponds to (nprevious,nnext), and the nprevious previous and nnext next histograms in hists are used for averaging (so window=(0,0) would correspond to no averaging) - weights: a list or numpy array containing the relative weights of the histograms in the averaging procedure. note: the weights can be any number, but they will be normalized to have unit sum. note: weights must have length nwindow+1 or nprevious+1+nnext. note: the default behaviour is a uniform array with values 1./(window+1) (or 1./(nprevious+1+nnext)) returns: - a numpy array with same shape as input but where each histogram is replaced by its running average notes: - at the edges, the weights are cropped to match the input array and renormalized - this function will throw an error when the length of the set of histograms is smaller than the total window length, maybe extend later (although this is not normally needed)","title":"running_average_hists"},{"location":"utils/hist_utils/#select95random","text":"full signature: def select_random(hists, nselect=10) comments: select nselect random examples from a set of histograms input arguments: - hists: a numpy array of shape (nhistograms, nbins) for 1D or (nhistograms, nybins, nxbins) for 2D. - nselect: number of random instances to draw","title":"select_random"},{"location":"utils/hist_utils/#smoothhists","text":"full signature: def smoothhists(hists, halfwindow=None, weights=None) comments: perform histogram smoothing by averaging over neighbouring bins input arguments: - hists: a numpy array of shape (nhistograms, nbins) for 1D or (nhistograms, nybins, nxbins) for 2D. - halfwindow: number of bins to consider for the averaging; for 1D histograms, must be an int, corresponding to the number of bins before and after the current bin to average over; for 2D histograms, must be a tuple of (halfwindow_y, halfwindow_x). - weights: numpy array containing the relative weights of the bins for the averaging; for 1D histograms, must have length 2*halfwindow+1; for 2D histograms, must have shape (2*halfwindow_y+1, 2*halfwindow_x+1). note: the weights can be any number, but they will be normalized to have unit sum. note: the default behaviour is a uniform array returns: - a numpy array with same shape as input but where each histogram is replaced by its smoothed version","title":"smoothhists"},{"location":"utils/hist_utils/#get95smoothinghalfwindow95from95str","text":"full signature: def get_smoothinghalfwindow_from_str(windowstr) comments: get a valid smoothing half window (int or tuple) from a string (e.g. argument in gui) note: the resulting factor is typically passed to smoothhists (see above) input arguments: - windowstr: string representation of smoothing window e.g. '4' for 4 (for 1D histograms) e.g. '4,4' for (4,4) (for 2D histograms)","title":"get_smoothinghalfwindow_from_str"},{"location":"utils/hist_utils/#moment","text":"full signature: def moment(bins, counts, order) comments: get n-th central moment of a histogram input arguments: - bins: a 1D or 2D np array holding the bin centers (shape (nbins) or (nhistograms,nbins)) - counts: a 2D np array containing the bin counts (shape (nhistograms,nbins)) - order: the order of the moment to calculate (0 = maximum value, 1 = mean value) returns: - an array of shape (nhistograms) holding the requested moment per histogram notes: - for now only 1D histograms are supported!","title":"moment"},{"location":"utils/hist_utils/#histmean","text":"full signature: def histmean(bins, counts) comments: special case of moment calculation (with order=1)","title":"histmean"},{"location":"utils/hist_utils/#histrms","text":"full signature: def histrms(bins, counts) comments: special case of moment calculation","title":"histrms"},{"location":"utils/hist_utils/#histmoments","text":"full signature: def histmoments(bins, counts, orders) comments: apply moment calculation for a list of orders input arguments: - see function moment(bins, counts, order), the only difference being that orders is a list instead of a single number returns: - a numpy array of shape (nhistograms,nmoments)","title":"histmoments"},{"location":"utils/hist_utils/#preparedatafromnpy","text":"full signature: def preparedatafromnpy(dataname, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True, doplot=False) comments: read a .npy file and output the histograms input arguments: - see e.g. preparedatafromdf notes: - not yet tested for 2D histograms, but is expected to work...","title":"preparedatafromnpy"},{"location":"utils/hist_utils/#preparedatafromdf","text":"full signature: def preparedatafromdf(df, returnrunls=False, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=False, doplot=False) comments: prepare the data contained in a dataframe in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - smoothinghalfwindow: int or tuple (for 1D/2D histograms) used for smoothing the histograms - smoothingweights: 1D or 2D array (for 1D/2D histograms) with weights for smoothing - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"preparedatafromdf"},{"location":"utils/hist_utils/#preparedatafromcsv","text":"full signature: def preparedatafromcsv(dataname, returnrunls=False, cropslices=None, rebinningfactor=None, smoothinghalfwindow=None, smoothingweights=None, averagewindow=None, averageweights=None, donormalize=True, doplot=False) comments: prepare the data contained in a dataframe csv file in the form of a numpy array input arguments: - returnrunls: boolean whether to return a tuple of (histograms, run numbers, lumisection numbers). (default: return only histograms) - cropslices: list of slices (one per dimension) by which to crop the historams (default: no cropping) - rebinningfactor: an integer (or tuple of integers for 2D histograms) to downsample/rebin the histograms (default: no rebinning) - smoothinghalfwindow: int or tuple (for 1D/2D histograms) used for smoothing the histograms - smoothingweights: 1D or 2D array (for 1D/2D histograms) with weights for smoothing - donormalize: boolean whether to normalize the data - doplot: if True, some example plots are made showing the histograms","title":"preparedatafromcsv"},{"location":"utils/json_utils/","text":"json utils A collection of useful basic functions for manipulating json files. Functionality includes: - reading and writing json files for given sets of run numbers and lumisection numbers - checking if a given run number, lumisection number or combination is present in a given json file Note that the json files are always assumed to contain the following structure: - dict - run number (in string format) - list - list of two elements - starting lumisection number, ending lumisection number Example: { \"294927\": [ [ 55,85 ], [ 95,105] ] } There is one exception to this rule: instead of [ start, stop ], the lumisection list can also be [ -1 ], which is short for all lumisections within that run. loadjson full signature: def loadjson( jsonfile ) comments: load the content of a json file into a python object input arguments: - jsonfile: the name (or full path if needed) to the json file to be read output: - an dict object as specified in the note below note: the json file is supposed to contain an object like this example: { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } although no explicit checking is done in this function, objects that don't have this structure will probably lead to errors further in the code writejson full signature: def writejson( jsondict, outputfile, overwrite=False ) comments: inverse function of loadjson input arguments - jsondict: dict object to be written to a json file - outputfile: output file to be written, extension '.json' will be appended automatically - overwrite: boolean whether to overwrite outputfile if it exists (default: throw exception) injson_single full signature: def injson_single( run, lumi, jsondict ) comments: helper function for injson, only for internal use input arguments: - run and lumi are integers - jsondict is an object loaded from a json file output: - boolean whether the run/lumi combination is in the json dict injson full signature: def injson( run, lumi, jsonfile=None, jsondict=None ) comments: find if a run and lumi combination is in a given json file input arguments: - run and lumi: integers or (equally long) arrays of integers - jsonfile: a path to a json file - jsondict: a dict loaded from a json file note: either jsonfile or jsondict must not be None! output: boolean or array of booleans (depending on run and lumi) getjsondir full signature: def getjsondir() comments: internal helper function returning the path to where json files are stored isgolden full signature: def isgolden(run, lumi) comments: find if a run and lumi combination is in the golden json file input arguments: - run and lumi: either integers or (equally long) arrays of integers isdcson full signature: def isdcson(run, lumi) comments: find if a run and lumi combination is in DCS-only json file input arguments: - run and lumi: either integers or (equally long) arrays of integers plainlist_to_rangelist full signature: def plainlist_to_rangelist( plainlist ) comments: helper function for tuplelist_to_jsondict, only for internal use input arguments: - plainlist: a list of integers in increasing order, must have length >= 2 output: - a list lists representing ranges example: [1,2,3,5,6] -> [ [1,3], [5,6] ] rangelist_to_plainlist full signature: def rangelist_to_plainlist( rangelist ) comments: inverse function of plainlist_to_rangelist, for internal use only tuplelist_to_jsondict full signature: def tuplelist_to_jsondict( tuplelist ) comments: convert a list of tuples of format (run number, [lumisection numbers]) to json dict jsondict_to_tuplelist full signature: def jsondict_to_tuplelist( jsondict ) comments: inverse function of tuplelist_to_jsondict get_lcs full signature: def get_lcs( jsonlist ) comments: return a jsondict object that is the largest common subset (LCS) between the jsondict objects in jsonlist input arguments: - jsonlist: a list of dicts in the conventional json format, so each element in jsonlist must be e.g. { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } remark: this is probably not the most efficient implementation, open for improvement...","title":"json_utils"},{"location":"utils/json_utils/#json-utils","text":"A collection of useful basic functions for manipulating json files. Functionality includes: - reading and writing json files for given sets of run numbers and lumisection numbers - checking if a given run number, lumisection number or combination is present in a given json file Note that the json files are always assumed to contain the following structure: - dict - run number (in string format) - list - list of two elements - starting lumisection number, ending lumisection number Example: { \"294927\": [ [ 55,85 ], [ 95,105] ] } There is one exception to this rule: instead of [ start, stop ], the lumisection list can also be [ -1 ], which is short for all lumisections within that run.","title":"json utils"},{"location":"utils/json_utils/#loadjson","text":"full signature: def loadjson( jsonfile ) comments: load the content of a json file into a python object input arguments: - jsonfile: the name (or full path if needed) to the json file to be read output: - an dict object as specified in the note below note: the json file is supposed to contain an object like this example: { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } although no explicit checking is done in this function, objects that don't have this structure will probably lead to errors further in the code","title":"loadjson"},{"location":"utils/json_utils/#writejson","text":"full signature: def writejson( jsondict, outputfile, overwrite=False ) comments: inverse function of loadjson input arguments - jsondict: dict object to be written to a json file - outputfile: output file to be written, extension '.json' will be appended automatically - overwrite: boolean whether to overwrite outputfile if it exists (default: throw exception)","title":"writejson"},{"location":"utils/json_utils/#injson95single","text":"full signature: def injson_single( run, lumi, jsondict ) comments: helper function for injson, only for internal use input arguments: - run and lumi are integers - jsondict is an object loaded from a json file output: - boolean whether the run/lumi combination is in the json dict","title":"injson_single"},{"location":"utils/json_utils/#injson","text":"full signature: def injson( run, lumi, jsonfile=None, jsondict=None ) comments: find if a run and lumi combination is in a given json file input arguments: - run and lumi: integers or (equally long) arrays of integers - jsonfile: a path to a json file - jsondict: a dict loaded from a json file note: either jsonfile or jsondict must not be None! output: boolean or array of booleans (depending on run and lumi)","title":"injson"},{"location":"utils/json_utils/#getjsondir","text":"full signature: def getjsondir() comments: internal helper function returning the path to where json files are stored","title":"getjsondir"},{"location":"utils/json_utils/#isgolden","text":"full signature: def isgolden(run, lumi) comments: find if a run and lumi combination is in the golden json file input arguments: - run and lumi: either integers or (equally long) arrays of integers","title":"isgolden"},{"location":"utils/json_utils/#isdcson","text":"full signature: def isdcson(run, lumi) comments: find if a run and lumi combination is in DCS-only json file input arguments: - run and lumi: either integers or (equally long) arrays of integers","title":"isdcson"},{"location":"utils/json_utils/#plainlist95to95rangelist","text":"full signature: def plainlist_to_rangelist( plainlist ) comments: helper function for tuplelist_to_jsondict, only for internal use input arguments: - plainlist: a list of integers in increasing order, must have length >= 2 output: - a list lists representing ranges example: [1,2,3,5,6] -> [ [1,3], [5,6] ]","title":"plainlist_to_rangelist"},{"location":"utils/json_utils/#rangelist95to95plainlist","text":"full signature: def rangelist_to_plainlist( rangelist ) comments: inverse function of plainlist_to_rangelist, for internal use only","title":"rangelist_to_plainlist"},{"location":"utils/json_utils/#tuplelist95to95jsondict","text":"full signature: def tuplelist_to_jsondict( tuplelist ) comments: convert a list of tuples of format (run number, [lumisection numbers]) to json dict","title":"tuplelist_to_jsondict"},{"location":"utils/json_utils/#jsondict95to95tuplelist","text":"full signature: def jsondict_to_tuplelist( jsondict ) comments: inverse function of tuplelist_to_jsondict","title":"jsondict_to_tuplelist"},{"location":"utils/json_utils/#get95lcs","text":"full signature: def get_lcs( jsonlist ) comments: return a jsondict object that is the largest common subset (LCS) between the jsondict objects in jsonlist input arguments: - jsonlist: a list of dicts in the conventional json format, so each element in jsonlist must be e.g. { \"294927\": [ [ 55,85 ], [ 95,105] ], \"294928\": [ [1,33 ] ] } remark: this is probably not the most efficient implementation, open for improvement...","title":"get_lcs"},{"location":"utils/mask_utils/","text":"mask utils Utilities for working with HistStruct masks Mostly meant for internal use. get_combined_name full signature: def get_combined_name( masklist ) comments: concatenate all the masknames in masklist to a combined name input arguments: - masklist: list of strings output: string with contatenated name","title":"mask_utils"},{"location":"utils/mask_utils/#mask-utils","text":"Utilities for working with HistStruct masks Mostly meant for internal use.","title":"mask utils"},{"location":"utils/mask_utils/#get95combined95name","text":"full signature: def get_combined_name( masklist ) comments: concatenate all the masknames in masklist to a combined name input arguments: - masklist: list of strings output: string with contatenated name","title":"get_combined_name"},{"location":"utils/plot_utils/","text":"plot utils A collection of useful basic functions for plotting. make_legend_opaque full signature: def make_legend_opaque( leg ) comments: set the transparency of all entries in a legend to zero add_text full signature: def add_text( ax, text, pos, fontsize=10, horizontalalignment='left', verticalalignment='bottom', background_facecolor=None, background_alpha=None, background_edgecolor=None, **kwargs ) comments: add text to an axis at a specified position (in relative figure coordinates) input arguments: - ax: matplotlib axis object - text: string, can contain latex syntax such as /textbf{} and /textit{} - pos: tuple with relative x- and y-axis coordinates of bottom left corner add_cms_label full signature: def add_cms_label( ax, pos=(0.1,0.9), extratext=None, **kwargs ) comments: add the CMS label and extra text (e.g. 'Preliminary') to a plot special case of add_text, for convenience make_text_latex_safe full signature: def make_text_latex_safe( text ) comments: make a string safe to process with matplotlib's latex parser in case no tex parsing is wanted (e.g. escape underscores) to be extended when the need arises! plot_hists full signature: def plot_hists(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None, bkgcolor=None, bkgcmap='spring', bkgrange=None, bkgtitle=None) comments: plot some histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing colors (in string format), of length nhistograms note: it can also be a single string representing a color (in pyplot), then all histograms will take this color - labellist is a list or array containing labels for in legend, of length nhistograms - xlims is a tuple of min and max for the x-axis labels, defaults to (-0.5,nbins-0.5) - title, xaxtitle, yaxtitle: strings for histogram title, x-axis title and y-axis title respectively - bkgcolor: 1D array representing background color for the plot (color axis will be scaled between min and max in bkgcolor) note: if bkgcolor does not have the same length as the x-axis, it will be compressed or stretched to fit the axis, but this might be meaningless, depending on what you are trying to visualize! - bkgmap: name of valid pyplot color map for plotting the background color output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it plot_hists_from_df full signature: def plot_hists_from_df(df, histtype, nhists) comments: plot a number of histograms in a dataframe - df is the dataframe from which to plot - histtype is the name of the histogram type (e.g. 'chargeInner_PXLayer_1') - nhists is the number of histograms to plot plot_hists_multi full signature: def plot_hists_multi(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, caxtitle=None, caxtitlesize=None, caxtitleoffset=None, remove_underflow=False, remove_overflow=False, ylims=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None ) comments: plot many histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing numbers to be mapped to colors - labellist is a list or array containing labels for in legend output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it plot_sets full signature: def plot_sets(setlist, fig=None, ax=None, colorlist=[], labellist=[], transparencylist=[], title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, xlims=(-0.5,-1), remove_underflow=False, remove_overflow=False, yaxtitle=None, yaxtitlesize=None, ylims=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None) comments: plot multiple sets of 1D histograms to compare the shapes - setlist is a list of 2D numpy arrays containing histograms - fig and ax: a pyplot figure and axis object (if one of both is none a new figure is created) - title is a string that will be used as the title for the ax object other parameters are lists of which each element applies to one list of histograms plot_anomalous full signature: def plot_anomalous(histlist, ls, highlight=-1, hrange=-1) comments: plot a range of 1D histograms and highlight one of them input arguments: - histlist and ls: a list of histograms and corresponding lumisection numbers - highlight: the lumisection number of the histogram to highlight - hrange: the number of histograms before and after lsnumber to plot (default: whole run) plot_hist_2d full signature: def plot_hist_2d(hist, fig=None, ax=None, title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, ticklabelsize=None, colorticklabelsize=None, extent=None, caxrange=None) comments: plot a 2D histogram - hist is a 2D numpy array of shape (nxbins, nybins) notes: - if the histogram contains only nonnegative values, values below 1e-12 will not be plotted (i.e. they will be shown as white spots in the plot) to discriminate zero from small but nonzero - if the histogram contains negative values, the color axis will be symmetrized around zero plot_hists_2d full signature: def plot_hists_2d(hists, ncols=4, axsize=5, title=None, titlesize=None, subtitles=None, subtitlesize=None, xaxtitles=None, yaxtitles=None, **kwargs) comments: plot multiple 2D histograms next to each other input arguments - hists: list of 2D numpy arrays of shape (nxbins,nybins), or an equivalent 3D numpy array - ncols: number of columns to use - figsize: approximate size of a single axis in the figure (will be modified by aspect ratio) - title, titlesize: properties of the super title for the entire figure - subtitles, subtitlesize: properties of the individual histogram titles - xaxtitles, yaxtitles: properties of axis titles of individual histograms - kwargs: passed down to plot_hist_2d plot_hists_2d_gif full signature: def plot_hists_2d_gif(hists, titles=None, xaxtitle=None, yaxtitle=None, duration=0.3, figname='temp_gif.gif') comments: (no valid documentation found) plot_moments full signature: def plot_moments(moments, ls, dims=(0,1), fig=None, ax=None, markersize=10) comments: plot the moments of a set of histograms input arguments: - moments: a numpy array of shape (nhists,nmoments) - dims: a tuple of two or three values between 0 and nmoments-1 plot_distance full signature: def plot_distance(dists, ls=None, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='distance metric') comments: (no valid documentation found) plot_loss full signature: def plot_loss(data, loss_key='loss', val_loss_key='val_loss', title=None, titlesize=None, xaxtitle='Epoch', xaxtitlesize=None, yaxtitle='Loss', yaxtitlesize=None, xlims=None, yaxlog=True, legendsize=None, legendloc='best', doshow=True) comments: plot the training and validation loss of a keras/tensorflow model input arguments: - data: the object returned by the .fit method when called upon a keras model - other: plot layout options plot_mse full signature: def plot_mse(mse, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='mse') comments: plot the mse's and return the mean and std input args: - mse is a 1D numpy array of mse scores - doplot: boolean whether to make a plot or simply return mean and std - rmlargest: fraction of largest mse's to remove (to avoid being too sensitive to outliers) plot_score_dist full signature: def plot_score_dist( scores, labels, fig=None, ax=None, nbins=20, normalize=False, siglabel='Signal', sigcolor='g', bcklabel='Background', bckcolor='r', title=None, titlesize=12, xaxtitle=None, xaxtitlesize=12, yaxtitle=None, yaxtitlesize=12, legendsize=None, legendloc='best', ticksize=None, doshow=True) comments: make a plot showing the distributions of the output scores for signal and background plot_score_dist_multi full signature: def plot_score_dist_multi( scores, labels=None, colors=None, fig=None, ax=None, nbins=20, normalize=False, linestyle=None, linewidth=1, title=None, titlesize=12, xaxtitle=None, xaxtitlesize=12, yaxtitle=None, yaxtitlesize=12, legendsize=None, legendloc='best', ticksize=None, dolegend=True ) comments: plot the distribution of output scores for arbitrarily many sets (not limited to 'signal' and 'background') input arguments: - scores: list of numpy arrays of scores - labels: list of legend entries for the scores, must have same length as scores or be None (no legend) - colors: list of colors for the different score arrays, must have same length as scores or be None (default colors) plot_score_ls full signature: def plot_score_ls( thisscore, refscores, fig=None, ax=None, thislabel='This LS', thiscolor='black', reflabel='Reference LS', refcolor='dodgerblue', **kwargs ) comments: make a plot of the score for a single lumisection comparing to some reference distribution plot_metric full signature: def plot_metric( wprange, metric, label=None, color=None, sig_eff=None, sig_label=None, sig_color=None, bck_eff=None, bck_label=None, bck_color=None, title=None, xaxtitle='working point', yaxlog=False, ymaxfactor=1.3, yaxtitle='metric' ) comments: plot a metric based on signal and background efficiencies. along with the metric, the actual signal and background efficiencies can be plotted as well. input arguments: - wprange, metric: equally long 1D-numpy arrays, x- and y-data respectively - label: label for the metric to put in the legend - color: color for the metric (default: blue) - sig_eff: 1D-numpy array of signal efficiencies corresponding to wprange - sig_label: label for sig_eff in the legend - color: color for sig_eff (default: green) - bck_eff, bck_label, bck_color: same as for signal - title, xaxtitle and yaxtitle: titles for the plot and axes - yaxlog: boolean whether to put y axis in log scale - ymaxfactor: factor to add extra space on the top of the plot (for the legend) plot_roc full signature: def plot_roc( sig_eff, bkg_eff, auc=None, sig_eff_unc=None, color='b', title=None, titlesize=None, xaxtitle='Background efficiency', xaxtitlesize=None, yaxtitle='Signal efficiency', yaxtitlesize=None, xaxlog=True, yaxlog=False, xlims='auto', ylims='auto', dogrid=True, ticksize=None, doshow=True ) comments: note: automatic determination of xlims and ylims assumes log scale for x-axis and lin scale for y-axis; might not work properly in other cases and ranges should be provided manually. plot_confusion_matrix full signature: def plot_confusion_matrix( tp, tn, fp, fn, true_positive_label='Good', true_negative_label='Anomalous', pred_positive_label='Predicted good', pred_negative_label='Predicted anomalous', xaxlabelsize=None, yaxlabelsize=None, textsize=None, colormap='Blues', colortitle=None ) comments: (no valid documentation found) color full signature: def color(value) comments: (no valid documentation found) valstr full signature: def valstr(value) comments: (no valid documentation found) clip_scores full signature: def clip_scores( scores ) comments: clip +-inf values in scores local copy of the same functions in autoencoder_utils.py (need to copy here locally to use in plot_fit_2d and plot_fit_1d without circular import...) plot_fit_2d full signature: def plot_fit_2d( points, fitfunc=None, figsize=(10,8), logprob=False, clipprob=False, onlycontour=False, xlims=5, ylims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None, caxtitle=None, caxtitlesize=None, caxrange=None, transparency=1, ticksize=None ) comments: make a 2D scatter plot of a point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims), where ndims is supposed to be 2 - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims and ylims: tuples of (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: overrides previous argument to set lower bound of plotting range at 0 in both dimensions. - xaxtitle and yaxtitle: titles for axes. plot_fit_2d_clusters full signature: def plot_fit_2d_clusters( points, clusters, figsize=(12,8), labels=None, colors=None, legendmarkerscale=1., legendsize=10, legendloc='best', legendbbox=None, **kwargs ) comments: make a 2D scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), where ndims is supposed to be 2, usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), where ndims is supposed to be 2, clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_2d note: onlycontour is set automatically and should not be in kwargs plot_fit_1d full signature: def plot_fit_1d( points, fitfunc=None, logprob=False, clipprob=False, onlycontour=False, xlims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None ) comments: make a 1D scatter plot of a point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims), where ndims is supposed to be 1 - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims: tuple of the form (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: set lower bound of plotting range at 0 (overrides xlims) - xaxtitle and yaxtitle: titles for axes. plot_fit_1d_clusters full signature: def plot_fit_1d_clusters( points, clusters, labels=None, colors=None, **kwargs ) comments: make a 1D scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), where ndims is supposed to be 1, usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), where ndims is supposed to be 1, clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_1d note: onlycontour is set automatically and should not be in kwargs","title":"plot_utils"},{"location":"utils/plot_utils/#plot-utils","text":"A collection of useful basic functions for plotting.","title":"plot utils"},{"location":"utils/plot_utils/#make95legend95opaque","text":"full signature: def make_legend_opaque( leg ) comments: set the transparency of all entries in a legend to zero","title":"make_legend_opaque"},{"location":"utils/plot_utils/#add95text","text":"full signature: def add_text( ax, text, pos, fontsize=10, horizontalalignment='left', verticalalignment='bottom', background_facecolor=None, background_alpha=None, background_edgecolor=None, **kwargs ) comments: add text to an axis at a specified position (in relative figure coordinates) input arguments: - ax: matplotlib axis object - text: string, can contain latex syntax such as /textbf{} and /textit{} - pos: tuple with relative x- and y-axis coordinates of bottom left corner","title":"add_text"},{"location":"utils/plot_utils/#add95cms95label","text":"full signature: def add_cms_label( ax, pos=(0.1,0.9), extratext=None, **kwargs ) comments: add the CMS label and extra text (e.g. 'Preliminary') to a plot special case of add_text, for convenience","title":"add_cms_label"},{"location":"utils/plot_utils/#make95text95latex95safe","text":"full signature: def make_text_latex_safe( text ) comments: make a string safe to process with matplotlib's latex parser in case no tex parsing is wanted (e.g. escape underscores) to be extended when the need arises!","title":"make_text_latex_safe"},{"location":"utils/plot_utils/#plot95hists","text":"full signature: def plot_hists(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None, bkgcolor=None, bkgcmap='spring', bkgrange=None, bkgtitle=None) comments: plot some histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing colors (in string format), of length nhistograms note: it can also be a single string representing a color (in pyplot), then all histograms will take this color - labellist is a list or array containing labels for in legend, of length nhistograms - xlims is a tuple of min and max for the x-axis labels, defaults to (-0.5,nbins-0.5) - title, xaxtitle, yaxtitle: strings for histogram title, x-axis title and y-axis title respectively - bkgcolor: 1D array representing background color for the plot (color axis will be scaled between min and max in bkgcolor) note: if bkgcolor does not have the same length as the x-axis, it will be compressed or stretched to fit the axis, but this might be meaningless, depending on what you are trying to visualize! - bkgmap: name of valid pyplot color map for plotting the background color output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it","title":"plot_hists"},{"location":"utils/plot_utils/#plot95hists95from95df","text":"full signature: def plot_hists_from_df(df, histtype, nhists) comments: plot a number of histograms in a dataframe - df is the dataframe from which to plot - histtype is the name of the histogram type (e.g. 'chargeInner_PXLayer_1') - nhists is the number of histograms to plot","title":"plot_hists_from_df"},{"location":"utils/plot_utils/#plot95hists95multi","text":"full signature: def plot_hists_multi(histlist, fig=None, ax=None, colorlist=[], labellist=[], transparency=1, xlims=(-0.5,-1), title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, caxtitle=None, caxtitlesize=None, caxtitleoffset=None, remove_underflow=False, remove_overflow=False, ylims=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None ) comments: plot many histograms (in histlist) in one figure using specified colors and/or labels - histlist is a list of 1D arrays containing the histograms (or a 2D array of shape (nhistograms,nbins)) - colorlist is a list or array containing numbers to be mapped to colors - labellist is a list or array containing labels for in legend output: tuple of figure and axis objects, that can be used to further tune the look of the figure or save it","title":"plot_hists_multi"},{"location":"utils/plot_utils/#plot95sets","text":"full signature: def plot_sets(setlist, fig=None, ax=None, colorlist=[], labellist=[], transparencylist=[], title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, xlims=(-0.5,-1), remove_underflow=False, remove_overflow=False, yaxtitle=None, yaxtitlesize=None, ylims=None, ymaxfactor=None, legendsize=None, opaque_legend=False, ticksize=None) comments: plot multiple sets of 1D histograms to compare the shapes - setlist is a list of 2D numpy arrays containing histograms - fig and ax: a pyplot figure and axis object (if one of both is none a new figure is created) - title is a string that will be used as the title for the ax object other parameters are lists of which each element applies to one list of histograms","title":"plot_sets"},{"location":"utils/plot_utils/#plot95anomalous","text":"full signature: def plot_anomalous(histlist, ls, highlight=-1, hrange=-1) comments: plot a range of 1D histograms and highlight one of them input arguments: - histlist and ls: a list of histograms and corresponding lumisection numbers - highlight: the lumisection number of the histogram to highlight - hrange: the number of histograms before and after lsnumber to plot (default: whole run)","title":"plot_anomalous"},{"location":"utils/plot_utils/#plot95hist952d","text":"full signature: def plot_hist_2d(hist, fig=None, ax=None, title=None, titlesize=None, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, ticklabelsize=None, colorticklabelsize=None, extent=None, caxrange=None) comments: plot a 2D histogram - hist is a 2D numpy array of shape (nxbins, nybins) notes: - if the histogram contains only nonnegative values, values below 1e-12 will not be plotted (i.e. they will be shown as white spots in the plot) to discriminate zero from small but nonzero - if the histogram contains negative values, the color axis will be symmetrized around zero","title":"plot_hist_2d"},{"location":"utils/plot_utils/#plot95hists952d","text":"full signature: def plot_hists_2d(hists, ncols=4, axsize=5, title=None, titlesize=None, subtitles=None, subtitlesize=None, xaxtitles=None, yaxtitles=None, **kwargs) comments: plot multiple 2D histograms next to each other input arguments - hists: list of 2D numpy arrays of shape (nxbins,nybins), or an equivalent 3D numpy array - ncols: number of columns to use - figsize: approximate size of a single axis in the figure (will be modified by aspect ratio) - title, titlesize: properties of the super title for the entire figure - subtitles, subtitlesize: properties of the individual histogram titles - xaxtitles, yaxtitles: properties of axis titles of individual histograms - kwargs: passed down to plot_hist_2d","title":"plot_hists_2d"},{"location":"utils/plot_utils/#plot95hists952d95gif","text":"full signature: def plot_hists_2d_gif(hists, titles=None, xaxtitle=None, yaxtitle=None, duration=0.3, figname='temp_gif.gif') comments: (no valid documentation found)","title":"plot_hists_2d_gif"},{"location":"utils/plot_utils/#plot95moments","text":"full signature: def plot_moments(moments, ls, dims=(0,1), fig=None, ax=None, markersize=10) comments: plot the moments of a set of histograms input arguments: - moments: a numpy array of shape (nhists,nmoments) - dims: a tuple of two or three values between 0 and nmoments-1","title":"plot_moments"},{"location":"utils/plot_utils/#plot95distance","text":"full signature: def plot_distance(dists, ls=None, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='distance metric') comments: (no valid documentation found)","title":"plot_distance"},{"location":"utils/plot_utils/#plot95loss","text":"full signature: def plot_loss(data, loss_key='loss', val_loss_key='val_loss', title=None, titlesize=None, xaxtitle='Epoch', xaxtitlesize=None, yaxtitle='Loss', yaxtitlesize=None, xlims=None, yaxlog=True, legendsize=None, legendloc='best', doshow=True) comments: plot the training and validation loss of a keras/tensorflow model input arguments: - data: the object returned by the .fit method when called upon a keras model - other: plot layout options","title":"plot_loss"},{"location":"utils/plot_utils/#plot95mse","text":"full signature: def plot_mse(mse, rmlargest=0., doplot=True, title=None, xaxtitle='lumisection number', yaxtitle='mse') comments: plot the mse's and return the mean and std input args: - mse is a 1D numpy array of mse scores - doplot: boolean whether to make a plot or simply return mean and std - rmlargest: fraction of largest mse's to remove (to avoid being too sensitive to outliers)","title":"plot_mse"},{"location":"utils/plot_utils/#plot95score95dist","text":"full signature: def plot_score_dist( scores, labels, fig=None, ax=None, nbins=20, normalize=False, siglabel='Signal', sigcolor='g', bcklabel='Background', bckcolor='r', title=None, titlesize=12, xaxtitle=None, xaxtitlesize=12, yaxtitle=None, yaxtitlesize=12, legendsize=None, legendloc='best', ticksize=None, doshow=True) comments: make a plot showing the distributions of the output scores for signal and background","title":"plot_score_dist"},{"location":"utils/plot_utils/#plot95score95dist95multi","text":"full signature: def plot_score_dist_multi( scores, labels=None, colors=None, fig=None, ax=None, nbins=20, normalize=False, linestyle=None, linewidth=1, title=None, titlesize=12, xaxtitle=None, xaxtitlesize=12, yaxtitle=None, yaxtitlesize=12, legendsize=None, legendloc='best', ticksize=None, dolegend=True ) comments: plot the distribution of output scores for arbitrarily many sets (not limited to 'signal' and 'background') input arguments: - scores: list of numpy arrays of scores - labels: list of legend entries for the scores, must have same length as scores or be None (no legend) - colors: list of colors for the different score arrays, must have same length as scores or be None (default colors)","title":"plot_score_dist_multi"},{"location":"utils/plot_utils/#plot95score95ls","text":"full signature: def plot_score_ls( thisscore, refscores, fig=None, ax=None, thislabel='This LS', thiscolor='black', reflabel='Reference LS', refcolor='dodgerblue', **kwargs ) comments: make a plot of the score for a single lumisection comparing to some reference distribution","title":"plot_score_ls"},{"location":"utils/plot_utils/#plot95metric","text":"full signature: def plot_metric( wprange, metric, label=None, color=None, sig_eff=None, sig_label=None, sig_color=None, bck_eff=None, bck_label=None, bck_color=None, title=None, xaxtitle='working point', yaxlog=False, ymaxfactor=1.3, yaxtitle='metric' ) comments: plot a metric based on signal and background efficiencies. along with the metric, the actual signal and background efficiencies can be plotted as well. input arguments: - wprange, metric: equally long 1D-numpy arrays, x- and y-data respectively - label: label for the metric to put in the legend - color: color for the metric (default: blue) - sig_eff: 1D-numpy array of signal efficiencies corresponding to wprange - sig_label: label for sig_eff in the legend - color: color for sig_eff (default: green) - bck_eff, bck_label, bck_color: same as for signal - title, xaxtitle and yaxtitle: titles for the plot and axes - yaxlog: boolean whether to put y axis in log scale - ymaxfactor: factor to add extra space on the top of the plot (for the legend)","title":"plot_metric"},{"location":"utils/plot_utils/#plot95roc","text":"full signature: def plot_roc( sig_eff, bkg_eff, auc=None, sig_eff_unc=None, color='b', title=None, titlesize=None, xaxtitle='Background efficiency', xaxtitlesize=None, yaxtitle='Signal efficiency', yaxtitlesize=None, xaxlog=True, yaxlog=False, xlims='auto', ylims='auto', dogrid=True, ticksize=None, doshow=True ) comments: note: automatic determination of xlims and ylims assumes log scale for x-axis and lin scale for y-axis; might not work properly in other cases and ranges should be provided manually.","title":"plot_roc"},{"location":"utils/plot_utils/#plot95confusion95matrix","text":"full signature: def plot_confusion_matrix( tp, tn, fp, fn, true_positive_label='Good', true_negative_label='Anomalous', pred_positive_label='Predicted good', pred_negative_label='Predicted anomalous', xaxlabelsize=None, yaxlabelsize=None, textsize=None, colormap='Blues', colortitle=None ) comments: (no valid documentation found)","title":"plot_confusion_matrix"},{"location":"utils/plot_utils/#color","text":"full signature: def color(value) comments: (no valid documentation found)","title":"color"},{"location":"utils/plot_utils/#valstr","text":"full signature: def valstr(value) comments: (no valid documentation found)","title":"valstr"},{"location":"utils/plot_utils/#clip95scores","text":"full signature: def clip_scores( scores ) comments: clip +-inf values in scores local copy of the same functions in autoencoder_utils.py (need to copy here locally to use in plot_fit_2d and plot_fit_1d without circular import...)","title":"clip_scores"},{"location":"utils/plot_utils/#plot95fit952d","text":"full signature: def plot_fit_2d( points, fitfunc=None, figsize=(10,8), logprob=False, clipprob=False, onlycontour=False, xlims=5, ylims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None, caxtitle=None, caxtitlesize=None, caxrange=None, transparency=1, ticksize=None ) comments: make a 2D scatter plot of a point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims), where ndims is supposed to be 2 - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims and ylims: tuples of (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: overrides previous argument to set lower bound of plotting range at 0 in both dimensions. - xaxtitle and yaxtitle: titles for axes.","title":"plot_fit_2d"},{"location":"utils/plot_utils/#plot95fit952d95clusters","text":"full signature: def plot_fit_2d_clusters( points, clusters, figsize=(12,8), labels=None, colors=None, legendmarkerscale=1., legendsize=10, legendloc='best', legendbbox=None, **kwargs ) comments: make a 2D scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), where ndims is supposed to be 2, usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), where ndims is supposed to be 2, clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_2d note: onlycontour is set automatically and should not be in kwargs","title":"plot_fit_2d_clusters"},{"location":"utils/plot_utils/#plot95fit951d","text":"full signature: def plot_fit_1d( points, fitfunc=None, logprob=False, clipprob=False, onlycontour=False, xlims=5, onlypositive=False, xaxtitle=None, xaxtitlesize=None, yaxtitle=None, yaxtitlesize=None, title=None, titlesize=None ) comments: make a 1D scatter plot of a point cloud with fitted contour input arguments: - points: a numpy array of shape (npoints,ndims), where ndims is supposed to be 1 - fitfunc: an object of type CloudFitter (see src/cloudfitters) or any other object that implements a pdf(points) method - logprob: boolean whether to plot log probability or normal probability - clipprob: boolean whether to replace +- inf values by (non-inf) max and min - onlycontour: a boolean whether to draw only the fit or include the data points - xlims: tuple of the form (low,high) note: can be an integer, in which case the range will be determined automatically from the formula low = mean-xlims*std, high = mean+xlims*std, where mean and std are determined from the points array. - onlypositive: set lower bound of plotting range at 0 (overrides xlims) - xaxtitle and yaxtitle: titles for axes.","title":"plot_fit_1d"},{"location":"utils/plot_utils/#plot95fit951d95clusters","text":"full signature: def plot_fit_1d_clusters( points, clusters, labels=None, colors=None, **kwargs ) comments: make a 1D scatter plot of a fitted contour with point clouds superimposed input arguments: - points: numpy arrays of shape (npoints,ndims), where ndims is supposed to be 1, usually the points to which the fit was done note: only used to determine plotting range, these points are not plotted! - clusters: list of numpy arrays of shape (npoints,ndims), where ndims is supposed to be 1, clouds of points to plot - labels: list with legend entries (must be same length as clusters) - colors: list with colors (must be same length as clusters) - kwargs: passed down to plot_fit_1d note: onlycontour is set automatically and should not be in kwargs","title":"plot_fit_1d_clusters"},{"location":"utils/refruns_utils/","text":"refruns utils Tools for retrieving a reference run for a given run Preliminary implementation, based on a json file generated by the Tracker DQM group. Retrieved from here . Perhaps modify code later to fetch the up-to-date version at runtime instead of having to download a new version. Maybe also using an API to retrieve only the requested run instead of loading the entire file into memory. get_reference_run full signature: def get_reference_run( runnb, jsonlist=None, jsonfile='json_allRunsRefRuns.json' ) comments: get the reference run for a given run number input arguments: - runnb: integer representing a run number. - jsonlist: list matching run numbers to reference run numbers. note: the list is supposed to contain dicts with keys 'run_number' and 'reference_run_number', this convention is based on the json file provided by the tracker group. note: if jsonlist is None, jsonfile (see below) will be opened and a jsonlist read from it. - jsonfile: path to json file matching run numbers to reference run numbers. note: the json file must contain a list of dicts with keys 'run_number' and 'reference_run_number', as explained above. note: ignored if jsonlist is not None. output: integer representing the reference run number for the given run. if the given run is not in the json, -1 is returned.","title":"refruns_utils"},{"location":"utils/refruns_utils/#refruns-utils","text":"Tools for retrieving a reference run for a given run Preliminary implementation, based on a json file generated by the Tracker DQM group. Retrieved from here . Perhaps modify code later to fetch the up-to-date version at runtime instead of having to download a new version. Maybe also using an API to retrieve only the requested run instead of loading the entire file into memory.","title":"refruns utils"},{"location":"utils/refruns_utils/#get95reference95run","text":"full signature: def get_reference_run( runnb, jsonlist=None, jsonfile='json_allRunsRefRuns.json' ) comments: get the reference run for a given run number input arguments: - runnb: integer representing a run number. - jsonlist: list matching run numbers to reference run numbers. note: the list is supposed to contain dicts with keys 'run_number' and 'reference_run_number', this convention is based on the json file provided by the tracker group. note: if jsonlist is None, jsonfile (see below) will be opened and a jsonlist read from it. - jsonfile: path to json file matching run numbers to reference run numbers. note: the json file must contain a list of dicts with keys 'run_number' and 'reference_run_number', as explained above. note: ignored if jsonlist is not None. output: integer representing the reference run number for the given run. if the given run is not in the json, -1 is returned.","title":"get_reference_run"}]}